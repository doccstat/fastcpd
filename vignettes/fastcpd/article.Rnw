% \citep[][Chapter~7.4]{Venables+Ripley:2002}
% knitr::Sweave2knitr("article.Rnw"); knitr::knit("article-knitr.Rnw")
\documentclass[article]{jss}

%% -- LaTeX packages and custom commands ---------------------------------------

%% recommended packages
\usepackage{orcidlink,thumbpdf,lmodern}
\usepackage{mathtools}
\usepackage{booktabs}
\usepackage{multirow}

\usepackage{geometry}
\usepackage{pdflscape}

%% another package (only for this demo article)
\usepackage{framed}

%% new custom commands
\newcommand{\class}[1]{`\code{#1}'}
\newcommand{\fct}[1]{\code{#1()}}

%% For Sweave-based articles about R packages:
%% need no \usepackage{Sweave}
\SweaveOpts{engine=R, eps=FALSE, keep.source = TRUE}
<<preliminaries, echo=FALSE, results=hide>>=
options(prompt = "R> ", continue = "+  ", width = 70, useFancyQuotes = FALSE)
library(fastglm)
library(fastcpd)
library(glmnet)
library(doRNG)
set.seed(1)
@


%% -- Article metainformation (author, title, ...) -----------------------------

%% - \author{} with primary affiliation (and optionally ORCID link)
%% - \Plainauthor{} without affiliations
%% - Separate authors by \And or \AND (in \author) or by comma (in \Plainauthor).
%% - \AND starts a new line, \And does not.
\author{First Author~\orcidlink{0009-0006-2493-0853}\\Texas A\&M University
   \And Second Author~\orcidlink{0009-0006-2493-0853}\\Texas A\&M University}
\Plainauthor{First Author, Second Author}

%% - \title{} in title case
%% - \Plaintitle{} without LaTeX markup (if any)
%% - \Shorttitle{} with LaTeX markup (if any), used as running title
\title{\pkg{fastcpd}: Fast Change Point Detection in \proglang{R}}
\Plaintitle{fastcpd: Fast Change Point Detection in R}
\Shorttitle{Fast Change Point Detection in \proglang{R}}

%% - \Abstract{} almost as usual
\Abstract{
  TBD
}

%% - \Keywords{} with LaTeX markup, at least one required
%% - \Plainkeywords{} without LaTeX markup (if necessary)
%% - Should be comma-separated and in sentence case.
\Keywords{change point detection, gradient descent, quasi-newton, incremental gradient, \proglang{R}}
\Plainkeywords{change point detection, gradient descent, quasi-newton, incremental gradient, R}

%% - \Address{} of at least one author
%% - May contain multiple affiliations for each author
%%   (in extra lines, separated by \emph{and}\\).
%% - May contain multiple authors for the same affiliation
%%   (in the same first line, separated by comma).
\Address{
  Contact Author\\
  Journal of Statistical Software\\
  \emph{and}\\
  Department of Statistics\\
  Faculty of Economics and Statistics\\
  Universit\"at Innsbruck\\
  Universit\"atsstr.~15\\
  6020 Innsbruck, Austria\\
  E-mail: \email{Achim.Zeileis@R-project.org}\\
  URL: \url{https://www.zeileis.org/}
}

\begin{document}


%% -- Introduction -------------------------------------------------------------

\section[Introduction: Fast change point detection in R]{Introduction: Fast change point detection in \proglang{R}} \label{sec:intro}

Change-point analysis is a statistical technique used to detect changes in the
underlying properties of a data series. This technique has been widely applied
in various fields, such as finance, ecology, and signal processing, to identify
abrupt distributional changes in time series data.
Over the years, many different methods have
been proposed for change-point analysis, including both parametric and
nonparametric approaches.

Change points are also called switch points, break points, broken line
regression, broken stick regression, bilinear regression, piecewise linear
regression, local linear regression, segmented regression, and (performance)
discontinuity models \citep{lindelov2020mcp}. Industries often refer to another term called anomaly
detection without the need to specify the underlying distribution of
the data and the anomaly often comes from some external source, for example
a cyber attack. There are extensive research done on anomaly detection on time
series including \cite{shipmon2017time}, but the focus of this paper is on
change-point detection with the underlying distribution of the data known prior change.

Change-point analysis involves identifying and localizing structural changes in
the underlying model of a data sequence. The earliest work on this topic dates
back to the 1950s when the focus was on detecting a shift in the mean of an
independent and identically distributed Gaussian sequence for quality control
purposes in industry\cite{page1954continuous}. Since then, change-point analysis
has become an active
area of research in statistics and has found applications in diverse fields
such as signal processing, climate science, economics, finance, medicine, and
bioinformatics.

For readers interested in delving deeper into this subject, we recommend the
book-length treatments by \cite{brodsky1993nonparametric}, \cite{csorgo1997limit},
and \cite{tartakovsky2014sequential}. Additionally, reviews by
\cite{aue2013structural, niu2016multiple, aminikhanghahi2017survey, truong2020selective, liu2022high}
offer valuable insights into the current state-of-the-art and
recent developments in change-point analysis.

This paper is focused on offline change-point detection methods, which are used
to retrospectively detect changes in data sequences. There are two main branches
of change-point detection methods: online methods and offline methods. Online
methods aim to detect changes as early as possible, while offline methods detect
changes once all samples have been observed. Another subject called anomaly
detection is also often studied in industry companies for security reasons,
which can be considered as a subset of the online detection problems.
\cite{shipmon2017time} conducted research on anomaly detection based on time
series. The offline approach typically
involves three components: the cost function, the search method, and the
penalty/constraint \cite{truong2020selective}. The choice of the cost function
and search method has a
significant impact on computational complexity. As large data sets become more
common in modern applications, more efficient algorithms are needed to handle
them. One popular approach is to cast change-point detection as a
model-selection problem by solving a penalized optimization problem over
possible numbers and locations of change-points. Dynamic programming is used to
solve this optimization problem exactly, but this can be computationally
expensive \cite{auger1989algorithms, jackson2005algorithm}. Two pruning
strategies \cite{killick2012optimal, rigaill2010pruned} have been introduced to
reduce computational
cost: PELT and an alternative pruned dynamic programming algorithm. However,
these pruning strategies still result in a computational cost of
$O(\sum_{t = 1}^T \sum_{s = 1}^t q(s))$
in the worst case scenario, where $T$ is the number of data points and $q(s)$
denotes the time complexity for calculating the cost function value based on $s$
data points. \cite{zhang2022sequential} proposes a new sequential updating
method (SE)
that can be coupled with the gradient descent (SeGD) and quasi-Newton's method
(SeN) to update the parameter estimate and cost value in dynamic programming.
The new strategy significantly improves computational efficiency by avoiding
repeated optimization of the objective function based on each data segment. The
proposed method applies to a broad class of statistical models and can be
regarded as a new approximation scheme for the $l_0$ penalization problem.

Based on the manuscript from \citep{zhang2022sequential}, we have developed an
R package with proper extension and modifications, called
\pkg{fastcpd} (\textbf{FAST} \textbf{C}hange \textbf{P}oint \textbf{D}etection)
for fast offline change-point detection.
Change-point detection is an important problem in many fields, including signal
processing, finance, and biology. Given a sequence of data points, a
change-point detection algorithm identifies points where the underlying
statistical properties of the data change. \pkg{fastcpd} implements a novel
approach for change-point detection that is orders of magnitude faster than
existing methods, without sacrificing accuracy.

The \pkg{fastcpd} method is based on a sequential optimization algorithm that
uses gradient descent to efficiently search for change-points. The algorithm is
designed to minimize a cost function that captures the likelihood of observing
the data given a particular segmentation. The key idea is to update the cost
function using information from previous steps, rather than re-optimizing the
objective function at each step. This allows \pkg{fastcpd} to quickly identify
change-points in long sequences of data, even when the cost function involves
solving a non-trivial optimization problem.

\pkg{fastcpd} supports change-point detection in a variety of settings,
including generalized linear models and penalized regression. The package
provides a simple and intuitive interface for users to specify their data and
desired parameters, and produces output in a convenient format for further
analysis. In addition, \pkg{fastcpd} includes a suite of visualization tools for
exploring the results of the change-point detection algorithm.

We believe that \pkg{fastcpd} will be a valuable tool for researchers and
practitioners working with change-point detection problems. By providing fast
and accurate change-point detection in a user-friendly package, \pkg{fastcpd}
will enable users to more easily analyze and understand complex datasets.

% We will only brief introduce some of the existing packages for online change
% point detection since our focus is on offline change point detection.
% The \proglang{R} package \pkg{onlineBcp} from \citep{yiugiter2015online} provides a set of tools for online Bayesian
% change-point detection. It includes functions for fitting several Bayesian
% models, such as the Normal-Inverse-Gamma model and the Normal-Gamma model, and
% for updating the posterior distributions as new data becomes available. The
% package also allows for online inference of the change-point location and for
% estimating the parameters of the underlying distributions before and after the
% change-point. The package is useful for applications where data arrives
% sequentially and quickly, such as in sensor networks or social media analysis.

% https://www.marinedatascience.co/blog/2019/09/28/comparison-of-change-point-detection-methods/
% https://lindeloev.github.io/mcp/articles/packages.html
% are good sources for comparison of change point detection methods
The \proglang{R} package \pkg{changepoint} from \cite{killick2014changepoint}
has been developed to detect change points in mean and variance in the data with
the PELT algorithm.
The \proglang{R} package \pkg{bcp} from \citep{erdman2008bcp} is a implementation
of Bayesian methods from \cite{barry1993bayesian}.
The \proglang{R} package \pkg{strucchange} from \cite{zeileis2002strucchange}
reviews tests for structural change in linear regression models from the
generalized fluctuation test framework as well as from the F test (Chow test)
framework.
The \proglang{R} \pkg{segmented} from \cite{muggeo2008segmented} uses piecewise
linear regression to detect change points in the data.
The \proglang{R} package \pkg{cpm} from \citep{ross2015parametric} provides a
implementation of several change point models from 2003 to 2014 in both online
and offline settings.
The \proglang{R} package \pkg{ecp} from \citep{james2013ecp} is designed to
perform multiple change point analysis while making as few assumptions as possible.
The \proglang{R} package \pkg{mcp} from \citep{lindelov2020mcp} does regression
with one or Multiple Change Points (MCP) between Generalized and hierarchical
Linear Segments using Bayesian inference, aiming to provide maximum
flexibility for analyses with a priori knowledge about the number of change
points and the form of the segments in between.
Although the \proglang{R} package \pkg{tree} can also be used to detect change
points occasionally, it is not the main purpose of this package.
The \proglang{R} package \pkg{changepoints} \citep{changepoints2022} provides
implementation of several change point models from 2019 to 2021.

Overall there is not a method that is universal and fast enough for all
applications as far as we know. The \pkg{fastcpd} package is designed to be a
general framework for change point detection which is also fast enough to be
applied in all different kinds of data sets.

%% -- Manuscript ---------------------------------------------------------------

\section{Models and software} \label{sec:models}

Logistic regression, Poisson regression, linear regression, and penalized
linear regression have already been implemented in \pkg{fastcpd} package. Some
specifications are listed in Table~\ref{tab:models}. The signature of the main
function \fct{fastcpd} is
%
\begin{Code}
fastcpd(
  data,
  beta,
  segment_count = 10,
  trim = 0.025,
  momentum_coef = 0,
  sgd_k = 3,
  family = NULL,
  epsilon = 1e-10,
  min_prob = 10^10,
  winsorise_minval = -20,
  winsorise_maxval = 20,
  p = NULL,
  cost = negative_log_likelihood,
  cost_gradient = cost_update_gradient,
  cost_hessian = cost_update_hessian
)
\end{Code}
%
where each parameters have the following usages:
\begin{itemize}
  \item \code{data}: A data frame containing the data to be segmented where each
    row denotes each data point. In regression settings, the first column is the
    response variable while the rest are covariates.
  \item \code{beta}: Initial cost value specified in Algorithm~1 in
    \cite{zhang2022sequential}.
  \item \code{segment_count}: Number of segments for initial guess. If not
    specified, the initial guess on the number of segments is 10.
  \item \code{trim} Trimming for the boundary change points so that a change
    point close to the boundary will not be counted as a change point. This
    parameter also specifies the minimum distance between two change points. If
    several change points have mutual distances smaller than
    \code{trim * nrow(data)}, those change points will be merged into one single
    change point.
  \item \code{momentum_coef} Momentum coefficient to be applied to each update.
    This parameter is used when the loss function is bad-shaped so that
    maintaining a momentum from previous update is desired. Default value is 0,
    meaning the algorithm doesn't maintain a momentum by default.
  \item \code{sgd_k} Number of epochs in for each update whenever the algorithm
    takes a new data point, in the sense that the data are analyzed sequentially
    according to the nature of Pruned Exact Linear Time (PELT) algorithm
    \citep{killick2012optimal}.
  \item \code{family} Family of the model. Can be ``\code{binomial}'', ``\code{poisson}'',
    ``\code{lasso}'', ``\code{gaussian}'' or ``\code{custom}''. For simplicity,
    user can also omit this parameter, indicating that they will be using their
    own cost functions. If specified as ``\code{custom}'' or ``\code{NULL}'', the user must
    specify the cost function, gradient and corresponding Hessian matrix.
    Hessian is preferred when the user want to specify their own cost function,
    but not analytically available, the user should provide a single number
    (diagonal matrix) to replace the Hessian matrix. Should be left as
    \code{NULL} if the user would like to use their own cost functions.
  \item \code{epsilon} Epsilon to avoid numerical issues. Only used for Logistic
    Regression and Poisson Regression.
  \item \code{min_prob} Minimum probability to avoid numerical issues. Only used
    for Poisson Regression.
  \item \code{winsorise_minval} Minimum value for the parameter in Poisson
    Regression to be winsorised.
  \item \code{winsorise_maxval} Maximum value for the parameter in Poisson
    Regression to be winsorised.
  \item \code{lambda} Lambda for L1 regularization. Only used in ``lasso''.
  \item \code{cost} Cost function to be used. This and the following two
    parameters should not be specified at the same time with \code{family}.
    If not specified, the default is the negative log-likelihood for the
    corresponding family.
  \item \code{cost_gradient} Gradient function for the custom cost function.
  \item \code{cost_hessian} Hessian function for the custom cost function.
\end{itemize}
Return of the function is a list containing two elements:
\begin{itemize}
  \item \code{cp_set}: A vector containing the change points.
  \item \code{cost_value}: Values of the cost function for each data segments
    separated by the change points.
\end{itemize}

A \class{fastcpd} object is returned by the function. This object can be used
to plot the change points and the cost function values. Compatible functions
include \fct{plot}, \fct{print} and \fct{summary}.

\begin{table}[t!]
\centering
\begin{tabular}{llp{10cm}}
\hline
Model               & \code{family}   & Description \\ \hline
Linear Regression   & \code{gaussian} & Will be using pre-defined cost functions,
                                        details can be found in
                                        Section~\ref{sec:linear model} \\
Logistic Regression & \code{binomial} & Will be using pre-defined cost functions,
                                        details can be found in
                                        Section~\ref{sec:logistic_regression} \\
Poisson Regression  & \code{poisson}  & Will be using pre-defined cost functions,
                                        details can be found in
                                        Section~\ref{sec:poisson} \\
LASSO               & \code{lasso}    & Will be using pre-defined cost functions,
                                        details can be found in
                                        Section~\ref{sec:linear model} \\ \hline
User-defined Model  & \code{custom}   & If \code{family} is specified as ``custom''
                                        or \code{NULL}, \code{cost}, \code{cost_gradient}
                                        and \code{cost_hessian} must be provided. \\
Huber Regression    & \code{custom}   & Instead of providing Huber Regression
                                        as a built-in model, we provide an example
                                        of how to use \code{custom} model. Details
                                        can be found in Section~\ref{sec:huber} \\
Quantile Regression & \code{custom}   & Instead of providing Quantile Regression
                                        as a built-in model, we provide an example
                                        of how to use \code{custom} model. Details
                                        can be found in Section~\ref{sec:quantile} \\
Mean Shift          & \code{custom}   & Instead of providing Quantile Regression
                                        as a built-in model, we provide an example
                                        of how to use \code{custom} model. Details
                                        can be found in Section~\ref{sec:mean shift model} \\ \hline
\end{tabular}
\caption{\label{tab:models} All the models that have been implemented in the
package, including an empty model so that the users are able to provide their
own.}
\end{table}

\section{Changes in linear models} \label{sec:linear model}

<<linear regression, echo=FALSE>>=
cost_glm_gaussian <- function(data, family="gaussian")
{
data <- as.matrix(data)
p <- dim(data)[2] - 1
out <- fastglm(as.matrix(data[,1:p]), data[,p+1], family=family)
return(out$deviance/2)
}

CP_vanilla_gaussian <- function(data, beta, cost=cost_glm_gaussian, trim = 0.025)
{
n <- dim(data)[1]
p <- dim(data)[2] - 1
Fobj <- c(-beta, 0)
cp_set <- list(NULL,0)
set <- c(0,1)
 for(t in 2:n)
 {
 m <- length(set)
 cval <- rep(NA, m)
  for(i in 1:m)
  {
  k <- set[i] + 1
  if(t-k>=p-1) cval[i] <- suppressWarnings(cost(data[k:t,])) else cval[i] <- 0
  }
 obj <- cval + Fobj[set+1] + beta
 min_val <- min(obj)
 ind <- which(obj==min_val)[1]
 cp_set_add <- c(cp_set[[set[ind]+1]], set[ind])
 cp_set <- append(cp_set,list(cp_set_add))
 ind2 <- (cval + Fobj[set+1]) <= min_val
 set <- c(set[ind2], t)
 Fobj <- c(Fobj, min_val)
 }
cp <- cp_set[[n+1]]
nLL <- 0

cp <- cp[(cp >= trim * n) & (cp <= (1 - trim) * n)]
cp <- sort(unique(c(0, cp)))

segment_indices <- which((diff(cp) < trim * n) == TRUE)
if (length(segment_indices) > 0) {
  cp <- floor(
    (cp[-(segment_indices + 1)] + cp[-segment_indices]) / 2
  )
}
cp_loc <- unique(c(0,cp,n))

for(i in 1:(length(cp_loc)-1))
 {
 seg <- (cp_loc[i]+1):cp_loc[i+1]
 data_seg <- data[seg,]
 out <- fastglm(as.matrix(data_seg[, 1:p]), data_seg[, p+1], family="gaussian")
 nLL <- out$deviance/2 + nLL
 }

output <- list(cp, nLL)
names(output) <- c("cp", "nLL")
return(output)
}


data_gen_lin <- function(n, p, true.coef, true.cp.loc, Sigma, evar) {
  loc <- unique(c(0, true.cp.loc, n))
  if(dim(true.coef)[2] != length(loc)-1) stop("true.coef and true.cp.loc do not match")
  x <- mvtnorm::rmvnorm(n, mean = rep(0, p), sigma = Sigma)
  y <- NULL
  for(i in 1:(length(loc)-1))
  {
    Xb <- x[(loc[i] + 1):loc[i + 1], ,drop=FALSE]%*%true.coef[,i,drop=FALSE]
    add <- Xb + rnorm(length(Xb), sd=sqrt(evar))
    y <- c(y, add)
  }
  data <- cbind(y, x)
  true_cluster <- rep(1:(length(loc)-1), diff(loc))
  result <- list(data, true_cluster)
  return(result)
}

data_setup <- purrr::cross_df(
  list(
    n = c(300, 600, 1500),
    p = c(1, 3, 5),
    change_points_count = c(0, 1, 3, 5)
  )
)

experiment_setup <- purrr::cross_df(
  list(
    data_setup_index = seq_len(nrow(data_setup)),
    sgd_k = c(1, 2, 3, 5, 7)
  )
)
experiment_num <- 100

rand_gd <- time_gd <- rep(list(rep(NA, experiment_num)), nrow(experiment_setup))
rng <- RNGseq(experiment_num * nrow(data_setup), 1)

cl <- parallel::makeCluster(parallel::detectCores(), outfile = paste0("log/ex.log"))
doParallel::registerDoParallel(cl)
experiment_result <- foreach::foreach(experiment_setup_index = seq_len(nrow(experiment_setup)), .packages = c("fastglm", "fastcpd", "fossil", "glmnet")) %:%
  foreach::foreach(experiment_index = seq_len(experiment_num), rrng = rng[(experiment_setup$data_setup_index[experiment_setup_index] - 1) * experiment_num + seq_len(experiment_num)], .combine = "rbind") %dopar% {
    rngtools::setRNG(rrng)
    experiment_setup_row <- experiment_setup[experiment_setup_index, ]
    n <- data_setup[experiment_setup$data_setup_index[experiment_setup_index], ]$n
    p <- data_setup[experiment_setup$data_setup_index[experiment_setup_index], ]$p
    change_points_count <- data_setup[experiment_setup$data_setup_index[experiment_setup_index], ]$change_points_count
    sgd_k <- experiment_setup_row$sgd_k

    if (p == 1) {
      theta_0 <- 1.2
    } else {
      theta_0 <- c(1, 1.2, -1, 0.5, -2)[seq_len(p)]
    }

    true.coef <- matrix(rep(theta_0, change_points_count + 1), nrow = p, ncol = change_points_count + 1)

    theta_norm <- c(0.36, NA, 0.81, NA, 1.96)[p]
    delta <- rnorm(p)
    sigma_ <- 0.9**abs(row(diag(p)) - col(diag(p)))
    delta_coef <- sqrt(theta_norm / t(delta) %*% sigma_ %*% delta)

    true.cp.loc <- sort(sample.int(n - 1, change_points_count, replace = FALSE))
    if (change_points_count == 1) {
      true.coef[, 2] <- theta_0 + c(delta_coef) * delta
    } else if (change_points_count == 3) {
      true.coef[, 2] <- theta_0 + c(delta_coef) * delta
      true.coef[, 4] <- theta_0 - c(delta_coef) * delta
    } else if (change_points_count == 5) {
      true.coef[, 2] <- theta_0 + c(delta_coef) * delta
      true.coef[, 4] <- theta_0 - c(delta_coef) * delta
      true.coef[, 6] <- theta_0 + c(delta_coef) * delta
    }

    Sigma <- diag(1, p)
    evar <- 0.5
    out <- data_gen_lin(n, p, true.coef, true.cp.loc, Sigma, evar)
    data <- out[[1]]
    g_tr <- out[[2]]
    beta <- log(n)/2

    if (file.exists(paste0("cache/linear", experiment_setup_index, "_", experiment_index, ".rds"))) {
      rds_file <- readRDS(paste0("cache/linear", experiment_setup_index, "_", experiment_index, ".rds"))
      cp_set <- rds_file$cp_set
      time_used <- rds_file$time_used
    } else {
      start <- proc.time()
      if (sgd_k == 7) {
        cp_set <- CP_vanilla_gaussian(data[, c(1:p + 1, 1)], beta)$cp
      } else if (sgd_k == 5) {
        linear_regression_result <- fastcpd(
          data = data,
          beta = beta,
          family = "gaussian",
          k = function(x, data_length = n) {
            if (x < data_length / 10 * 1 / 4) 5
            else if (x < data_length / 10 * 2 / 4) 3
            else if (x < data_length / 10 * 3 / 4) 1
            else 0
          },
          epsilon = 1e-5
        )
        cp_set <- linear_regression_result@cp_set
      } else {
        linear_regression_result <- fastcpd(
          data = data,
          beta = beta,
          family = "gaussian",
          k = function(x) sgd_k - 1,
          epsilon = 1e-5
        )
        cp_set <- linear_regression_result@cp_set
      }
      time_used <- unname((proc.time() - start)[3])
      saveRDS(list(data = data, cp_set = cp_set, time_used = time_used), paste0("cache/linear", experiment_setup_index, "_", experiment_index, ".rds"))
    }
    cp_gd <- cp_set[!(cp_set==0)]
    K_est <- length(cp_gd) + 1
    cp_un <- unique(c(0, cp_gd, n))
    g_est <- rep(1:K_est, diff(cp_un))
    c(fossil::rand.index(g_tr, g_est), time_used)
  }
parallel::stopCluster(cl)

get_result <- function(n, p, change_points_count, sgd_k) {
  data_setup_index <- which(
    data_setup$n == n &
    data_setup$p == p &
    data_setup$change_points_count == change_points_count
  )
  experiment_setup_index <- which(
    experiment_setup$data_setup_index == data_setup_index &
    experiment_setup$sgd_k == sgd_k
  )
  paste0(format(round(mean(experiment_result[[experiment_setup_index]][, 1]), 3), nsmall = 3), ", ", format(round(mean(experiment_result[[experiment_setup_index]][, 2]), 3), nsmall = 3), "s")
}
@
<<linear regression plot set up, echo=FALSE>>=
experiment_setup_index <- 25
experiment_setup_row <- experiment_setup[experiment_setup_index, ]
n <- data_setup[experiment_setup$data_setup_index[experiment_setup_index], ]$n
p <- data_setup[experiment_setup$data_setup_index[experiment_setup_index], ]$p
change_points_count <- data_setup[experiment_setup$data_setup_index[experiment_setup_index], ]$change_points_count
sgd_k <- experiment_setup_row$sgd_k

if (p == 1) {
  theta_0 <- 1.2
} else {
  theta_0 <- c(1, 1.2, -1, 0.5, -2)[seq_len(p)]
}

true.coef <- matrix(rep(theta_0, change_points_count + 1), nrow = p, ncol = change_points_count + 1)

theta_norm <- c(0.36, NA, 0.81, NA, 1.96)[p]
delta <- rnorm(p)
sigma_ <- 0.9**abs(row(diag(p)) - col(diag(p)))
delta_coef <- sqrt(theta_norm / t(delta) %*% sigma_ %*% delta)

true.cp.loc <- sort(sample.int(n - 1, change_points_count, replace = FALSE))
if (change_points_count == 1) {
  true.coef[, 2] <- theta_0 + c(delta_coef) * delta
} else if (change_points_count == 3) {
  true.coef[, 2] <- theta_0 + c(delta_coef) * delta
  true.coef[, 4] <- theta_0 - c(delta_coef) * delta
} else if (change_points_count == 5) {
  true.coef[, 2] <- theta_0 + c(delta_coef) * delta
  true.coef[, 4] <- theta_0 - c(delta_coef) * delta
  true.coef[, 6] <- theta_0 + c(delta_coef) * delta
}

Sigma <- diag(1, p)
evar <- 0.5
out <- data_gen_lin(n, p, true.coef, true.cp.loc, Sigma, evar)
data <- out[[1]]
g_tr <- out[[2]]
beta <- log(n)/2
linear_regression_result <- fastcpd(
  data = data,
  beta = beta,
  family = "gaussian",
  k = function(x) 0,
  epsilon = 1e-5
)
@
<<linear regression plot, fig=TRUE, height=5.2, width=7>>=
summary(linear_regression_result)
plot(linear_regression_result)
@

\newgeometry{margin=1cm}
\begin{landscape}

\begin{table}[t!]
  \centering
  \begin{tabular}{@{}cccccccccc@{}}
  \toprule
                          & \multicolumn{3}{c}{p=1}                                            & \multicolumn{3}{c}{p=3}                                            & \multicolumn{3}{c}{p=5}                                            \\
                          & n=300                & n=600                & n=1500               & n=300                & n=600                & n=1500               & n=300                & n=600                & n=1500               \\ \midrule
  \multirow{4}{*}{cpc=0} & \Sexpr{get_result(300, 1, 0, 1)} & \Sexpr{get_result(600, 1, 0, 1)} & \Sexpr{get_result(1500, 1, 0, 1)} & \Sexpr{get_result(300, 3, 0, 1)} & \Sexpr{get_result(600, 3, 0, 1)} & \Sexpr{get_result(1500, 3, 0, 1)} & \Sexpr{get_result(300, 5, 0, 1)} & \Sexpr{get_result(600, 5, 0, 1)} & \Sexpr{get_result(1500, 5, 0, 1)} \\
                          & \Sexpr{get_result(300, 1, 0, 2)} & \Sexpr{get_result(600, 1, 0, 2)} & \Sexpr{get_result(1500, 1, 0, 2)} & \Sexpr{get_result(300, 3, 0, 2)} & \Sexpr{get_result(600, 3, 0, 2)} & \Sexpr{get_result(1500, 3, 0, 2)} & \Sexpr{get_result(300, 5, 0, 2)} & \Sexpr{get_result(600, 5, 0, 2)} & \Sexpr{get_result(1500, 5, 0, 2)} \\
                          & \Sexpr{get_result(300, 1, 0, 3)} & \Sexpr{get_result(600, 1, 0, 3)} & \Sexpr{get_result(1500, 1, 0, 3)} & \Sexpr{get_result(300, 3, 0, 3)} & \Sexpr{get_result(600, 3, 0, 3)} & \Sexpr{get_result(1500, 3, 0, 3)} & \Sexpr{get_result(300, 5, 0, 3)} & \Sexpr{get_result(600, 5, 0, 3)} & \Sexpr{get_result(1500, 5, 0, 3)} \\
                          & \Sexpr{get_result(300, 1, 0, 5)} & \Sexpr{get_result(600, 1, 0, 5)} & \Sexpr{get_result(1500, 1, 0, 5)} & \Sexpr{get_result(300, 3, 0, 5)} & \Sexpr{get_result(600, 3, 0, 5)} & \Sexpr{get_result(1500, 3, 0, 5)} & \Sexpr{get_result(300, 5, 0, 5)} & \Sexpr{get_result(600, 5, 0, 5)} & \Sexpr{get_result(1500, 5, 0, 5)} \\
                          & \Sexpr{get_result(300, 1, 0, 7)} & \Sexpr{get_result(600, 1, 0, 7)} & \Sexpr{get_result(1500, 1, 0, 7)} & \Sexpr{get_result(300, 3, 0, 7)} & \Sexpr{get_result(600, 3, 0, 7)} & \Sexpr{get_result(1500, 3, 0, 7)} & \Sexpr{get_result(300, 5, 0, 7)} & \Sexpr{get_result(600, 5, 0, 7)} & \Sexpr{get_result(1500, 5, 0, 7)} \\ \midrule
  \multirow{4}{*}{cpc=1} & \Sexpr{get_result(300, 1, 1, 1)} & \Sexpr{get_result(600, 1, 1, 1)} & \Sexpr{get_result(1500, 1, 1, 1)} & \Sexpr{get_result(300, 3, 1, 1)} & \Sexpr{get_result(600, 3, 1, 1)} & \Sexpr{get_result(1500, 3, 1, 1)} & \Sexpr{get_result(300, 5, 1, 1)} & \Sexpr{get_result(600, 5, 1, 1)} & \Sexpr{get_result(1500, 5, 1, 1)} \\
                          & \Sexpr{get_result(300, 1, 1, 2)} & \Sexpr{get_result(600, 1, 1, 2)} & \Sexpr{get_result(1500, 1, 1, 2)} & \Sexpr{get_result(300, 3, 1, 2)} & \Sexpr{get_result(600, 3, 1, 2)} & \Sexpr{get_result(1500, 3, 1, 2)} & \Sexpr{get_result(300, 5, 1, 2)} & \Sexpr{get_result(600, 5, 1, 2)} & \Sexpr{get_result(1500, 5, 1, 2)} \\
                          & \Sexpr{get_result(300, 1, 1, 3)} & \Sexpr{get_result(600, 1, 1, 3)} & \Sexpr{get_result(1500, 1, 1, 3)} & \Sexpr{get_result(300, 3, 1, 3)} & \Sexpr{get_result(600, 3, 1, 3)} & \Sexpr{get_result(1500, 3, 1, 3)} & \Sexpr{get_result(300, 5, 1, 3)} & \Sexpr{get_result(600, 5, 1, 3)} & \Sexpr{get_result(1500, 5, 1, 3)} \\
                          & \Sexpr{get_result(300, 1, 1, 5)} & \Sexpr{get_result(600, 1, 1, 5)} & \Sexpr{get_result(1500, 1, 1, 5)} & \Sexpr{get_result(300, 3, 1, 5)} & \Sexpr{get_result(600, 3, 1, 5)} & \Sexpr{get_result(1500, 3, 1, 5)} & \Sexpr{get_result(300, 5, 1, 5)} & \Sexpr{get_result(600, 5, 1, 5)} & \Sexpr{get_result(1500, 5, 1, 5)} \\
                          & \Sexpr{get_result(300, 1, 1, 7)} & \Sexpr{get_result(600, 1, 1, 7)} & \Sexpr{get_result(1500, 1, 1, 7)} & \Sexpr{get_result(300, 3, 1, 7)} & \Sexpr{get_result(600, 3, 1, 7)} & \Sexpr{get_result(1500, 3, 1, 7)} & \Sexpr{get_result(300, 5, 1, 7)} & \Sexpr{get_result(600, 5, 1, 7)} & \Sexpr{get_result(1500, 5, 1, 7)} \\ \midrule
  \multirow{4}{*}{cpc=3} & \Sexpr{get_result(300, 1, 3, 1)} & \Sexpr{get_result(600, 1, 3, 1)} & \Sexpr{get_result(1500, 1, 3, 1)} & \Sexpr{get_result(300, 3, 3, 1)} & \Sexpr{get_result(600, 3, 3, 1)} & \Sexpr{get_result(1500, 3, 3, 1)} & \Sexpr{get_result(300, 5, 3, 1)} & \Sexpr{get_result(600, 5, 3, 1)} & \Sexpr{get_result(1500, 5, 3, 1)} \\
                          & \Sexpr{get_result(300, 1, 3, 2)} & \Sexpr{get_result(600, 1, 3, 2)} & \Sexpr{get_result(1500, 1, 3, 2)} & \Sexpr{get_result(300, 3, 3, 2)} & \Sexpr{get_result(600, 3, 3, 2)} & \Sexpr{get_result(1500, 3, 3, 2)} & \Sexpr{get_result(300, 5, 3, 2)} & \Sexpr{get_result(600, 5, 3, 2)} & \Sexpr{get_result(1500, 5, 3, 2)} \\
                          & \Sexpr{get_result(300, 1, 3, 3)} & \Sexpr{get_result(600, 1, 3, 3)} & \Sexpr{get_result(1500, 1, 3, 3)} & \Sexpr{get_result(300, 3, 3, 3)} & \Sexpr{get_result(600, 3, 3, 3)} & \Sexpr{get_result(1500, 3, 3, 3)} & \Sexpr{get_result(300, 5, 3, 3)} & \Sexpr{get_result(600, 5, 3, 3)} & \Sexpr{get_result(1500, 5, 3, 3)} \\
                          & \Sexpr{get_result(300, 1, 3, 5)} & \Sexpr{get_result(600, 1, 3, 5)} & \Sexpr{get_result(1500, 1, 3, 5)} & \Sexpr{get_result(300, 3, 3, 5)} & \Sexpr{get_result(600, 3, 3, 5)} & \Sexpr{get_result(1500, 3, 3, 5)} & \Sexpr{get_result(300, 5, 3, 5)} & \Sexpr{get_result(600, 5, 3, 5)} & \Sexpr{get_result(1500, 5, 3, 5)} \\
                          & \Sexpr{get_result(300, 1, 3, 7)} & \Sexpr{get_result(600, 1, 3, 7)} & \Sexpr{get_result(1500, 1, 3, 7)} & \Sexpr{get_result(300, 3, 3, 7)} & \Sexpr{get_result(600, 3, 3, 7)} & \Sexpr{get_result(1500, 3, 3, 7)} & \Sexpr{get_result(300, 5, 3, 7)} & \Sexpr{get_result(600, 5, 3, 7)} & \Sexpr{get_result(1500, 5, 3, 7)} \\ \midrule
  \multirow{4}{*}{cpc=5} & \Sexpr{get_result(300, 1, 5, 1)} & \Sexpr{get_result(600, 1, 5, 1)} & \Sexpr{get_result(1500, 1, 5, 1)} & \Sexpr{get_result(300, 3, 5, 1)} & \Sexpr{get_result(600, 3, 5, 1)} & \Sexpr{get_result(1500, 3, 5, 1)} & \Sexpr{get_result(300, 5, 5, 1)} & \Sexpr{get_result(600, 5, 5, 1)} & \Sexpr{get_result(1500, 5, 5, 1)} \\
                          & \Sexpr{get_result(300, 1, 5, 2)} & \Sexpr{get_result(600, 1, 5, 2)} & \Sexpr{get_result(1500, 1, 5, 2)} & \Sexpr{get_result(300, 3, 5, 2)} & \Sexpr{get_result(600, 3, 5, 2)} & \Sexpr{get_result(1500, 3, 5, 2)} & \Sexpr{get_result(300, 5, 5, 2)} & \Sexpr{get_result(600, 5, 5, 2)} & \Sexpr{get_result(1500, 5, 5, 2)} \\
                          & \Sexpr{get_result(300, 1, 5, 3)} & \Sexpr{get_result(600, 1, 5, 3)} & \Sexpr{get_result(1500, 1, 5, 3)} & \Sexpr{get_result(300, 3, 5, 3)} & \Sexpr{get_result(600, 3, 5, 3)} & \Sexpr{get_result(1500, 3, 5, 3)} & \Sexpr{get_result(300, 5, 5, 3)} & \Sexpr{get_result(600, 5, 5, 3)} & \Sexpr{get_result(1500, 5, 5, 3)} \\
                          & \Sexpr{get_result(300, 1, 5, 5)} & \Sexpr{get_result(600, 1, 5, 5)} & \Sexpr{get_result(1500, 1, 5, 5)} & \Sexpr{get_result(300, 3, 5, 5)} & \Sexpr{get_result(600, 3, 5, 5)} & \Sexpr{get_result(1500, 3, 5, 5)} & \Sexpr{get_result(300, 5, 5, 5)} & \Sexpr{get_result(600, 5, 5, 5)} & \Sexpr{get_result(1500, 5, 5, 5)} \\
                          & \Sexpr{get_result(300, 1, 5, 7)} & \Sexpr{get_result(600, 1, 5, 7)} & \Sexpr{get_result(1500, 1, 5, 7)} & \Sexpr{get_result(300, 3, 5, 7)} & \Sexpr{get_result(600, 3, 5, 7)} & \Sexpr{get_result(1500, 3, 5, 7)} & \Sexpr{get_result(300, 5, 5, 7)} & \Sexpr{get_result(600, 5, 5, 7)} & \Sexpr{get_result(1500, 5, 5, 7)} \\ \bottomrule
  \end{tabular}
  \caption{\label{tab:linear regression comparison} Comparison of the algorithms for the linear regression model in mean.}
\end{table}

\end{landscape}
\restoregeometry

\section{Changes in generalized linear models: Logistic regression} \label{sec:logistic_regression}

We first consider the change-point detection problem in the generalized linear
models (GLM). Suppose we have a data set containing a set of
predictors/covariates and corresponding response variables, i.e. each data point
\code{data[i, ]} contains a set of predictors/covariates \code{data[i, -1]} and
a response \code{data[i, 1]}. The reason we set the first column to be the
response variables are that in \proglang{R}, we can use \code{-1} to denote all
columns other than the first column without the need to consider number of
columns altogether.

Suppose the response variables follows a binomial distribution with specifics
defined as
%
\begin{equation} \label{eq:logistic_regression}
y_i \sim \mathrm{Bernoulli}\left(\frac{1}{1 + e^{- x_i^\top \theta_i}}\right),
\quad x_i \sim \mathcal{N}_p(0, \Sigma)\ \mathrm{with}\ \Sigma =
(0.9^{\lvert i - j \rvert})_{p \times p}, \quad 1 \le i \le n,
\end{equation}
%
where $\{y_i\}$ is the response variable, $\{x_i\}$ is the covariate vector,
$\Sigma$ is the covariance matrix for the sampling of $\{x_i\}$, $p$ is the
number of predictors, $n$ is the total number of data points.

We now use the \pkg{fastcpd} package to detect the change points in the data set
\code{data}. During the simulations, we vary the number of data points in
$\{300, 500, 1500\}$ and the dimensions $p$ to $\{1, 3, 5\}$ while varying $\theta_i$
to produce different magnitudes of change. We define $\delta_p$ as the difference
between the coefficients before and after a change-point and selected its value
such that $M(\delta_p):=\delta_p^\top \Sigma \delta_p \in \{0.36, 0.81, 1.96\}$,
representing small, medium, and large magnitudes of change, respectively. The
specific choice of $\delta_p$ does not affect the results as long as $M(\delta_p)$
is consistent. We evaluated the number of change-points at 0, 1, 3, and 5 for
each configuration, and the detailed simulation settings for each case are given
below.
%
<<vanilla pelt logistic regression, echo=FALSE>>=
data_gen_binom <- function(n, p, true.coef, true.cp.loc, Sigma, evar) {
  loc <- unique(c(0, true.cp.loc, n))
  if(dim(true.coef)[2] != length(loc)-1) stop("true.coef and true.cp.loc do not match")
  x <- mvtnorm::rmvnorm(n, mean = rep(0, p), sigma = Sigma)
  y <- NULL
  for(i in 1:(length(loc)-1))
  {
    Xb <- x[(loc[i] + 1):loc[i + 1], ,drop=FALSE]%*%true.coef[,i,drop=FALSE]
    y <- c(y, rbinom(loc[i + 1] - loc[i], 1, 1/(1 + exp(-Xb))))
  }
  data <- cbind(y, x)
  true_cluster <- rep(1:(length(loc)-1), diff(loc))
  result <- list(data, true_cluster)
  return(result)
}

cost_glm_binomial <- function(data, family="binomial")
{
data <- as.matrix(data)
p <- dim(data)[2] - 1
out <- fastglm(as.matrix(data[,1:p]), data[,p+1], family=family)
return(out$deviance/2)
}

CP_vanilla_binomial <- function(data, beta, cost=cost_glm_binomial, trim = 0.025)
{
n <- dim(data)[1]
p <- dim(data)[2] - 1
Fobj <- c(-beta, 0)
cp_set <- list(NULL,0)
set <- c(0,1)
 for(t in 2:n)
 {
 m <- length(set)
 cval <- rep(NA, m)
  for(i in 1:m)
  {
  k <- set[i] + 1
  if(t-k>=p-1) cval[i] <- suppressWarnings(cost(data[k:t,, drop = FALSE])) else cval[i] <- 0
  }
 obj <- cval + Fobj[set+1] + beta
 min_val <- min(obj)
 ind <- which(obj==min_val)[1]
 cp_set_add <- c(cp_set[[set[ind]+1]], set[ind])
 cp_set <- append(cp_set,list(cp_set_add))
 ind2 <- (cval + Fobj[set+1]) <= min_val
 set <- c(set[ind2], t)
 Fobj <- c(Fobj, min_val)
 }
cp <- cp_set[[n+1]]
nLL <- 0

cp <- cp[(cp >= trim * n) & (cp <= (1 - trim) * n)]
cp <- sort(unique(c(0, cp)))

segment_indices <- which((diff(cp) < trim * n) == TRUE)
if (length(segment_indices) > 0) {
  cp <- floor(
    (cp[-(segment_indices + 1)] + cp[-segment_indices]) / 2
  )
}
cp_loc <- unique(c(0,cp,n))
for(i in 1:(length(cp_loc)-1))
 {
 seg <- (cp_loc[i]+1):cp_loc[i+1]
 data_seg <- data[seg,]
 out <- fastglm(as.matrix(data_seg[, 1:p]), data_seg[, p+1], family="binomial")
 nLL <- out$deviance/2 + nLL
 }

output <- list(cp, nLL)
names(output) <- c("cp", "nLL")
return(output)
}

data_setup <- purrr::cross_df(
  list(
    n = c(300, 600, 1500),
    p = c(1, 3, 5),
    change_points_count = c(0, 1, 3, 5)
  )
)

experiment_setup <- purrr::cross_df(
  list(
    data_setup_index = seq_len(nrow(data_setup)),
    sgd_k = c(1, 2, 3, 5, 7)
  )
)
experiment_num <- 100

rand_gd <- time_gd <- rep(list(rep(NA, experiment_num)), nrow(experiment_setup))
rng <- RNGseq(experiment_num * nrow(data_setup), 2)

cl <- parallel::makeCluster(parallel::detectCores(), outfile = paste0("log/binom.log"))
doParallel::registerDoParallel(cl)
experiment_result <- foreach::foreach(experiment_setup_index = seq_len(nrow(experiment_setup)), .packages = c("fastglm", "fastcpd", "fossil", "glmnet")) %:%
  foreach::foreach(experiment_index = seq_len(experiment_num), rrng = rng[(experiment_setup$data_setup_index[experiment_setup_index] - 1) * experiment_num + seq_len(experiment_num)], .combine = "rbind") %dopar% {
    rngtools::setRNG(rrng)
    experiment_setup_row <- experiment_setup[experiment_setup_index, ]
    n <- data_setup[experiment_setup$data_setup_index[experiment_setup_index], ]$n
    p <- data_setup[experiment_setup$data_setup_index[experiment_setup_index], ]$p
    change_points_count <- data_setup[experiment_setup$data_setup_index[experiment_setup_index], ]$change_points_count
    sgd_k <- experiment_setup_row$sgd_k

    if (p == 1) {
      theta_0 <- 1.2
    } else {
      theta_0 <- c(1, 1.2, -1, 0.5, -2)[seq_len(p)]
    }

    true.coef <- matrix(rep(theta_0, change_points_count + 1), nrow = p, ncol = change_points_count + 1)

    theta_norm <- c(0.36, NA, 0.81, NA, 1.96)[p]
    delta <- rnorm(p)
    sigma_ <- 0.9**abs(row(diag(p)) - col(diag(p)))
    delta_coef <- sqrt(theta_norm / t(delta) %*% sigma_ %*% delta)

    true.cp.loc <- sort(sample.int(n - 1, change_points_count, replace = FALSE))
    if (change_points_count == 1) {
      true.coef[, 2] <- theta_0 + c(delta_coef) * delta
    } else if (change_points_count == 3) {
      true.coef[, 2] <- theta_0 + c(delta_coef) * delta
      true.coef[, 4] <- theta_0 - c(delta_coef) * delta
    } else if (change_points_count == 5) {
      true.coef[, 2] <- theta_0 + c(delta_coef) * delta
      true.coef[, 4] <- theta_0 - c(delta_coef) * delta
      true.coef[, 6] <- theta_0 + c(delta_coef) * delta
    }

    Sigma <- diag(1, p)
    evar <- 0.5
    out <- data_gen_binom(n, p, true.coef, true.cp.loc, Sigma, evar)
    data <- out[[1]]
    g_tr <- out[[2]]
    beta <- log(n)/2

    if (file.exists(paste0("cache/binom", experiment_setup_index, "_", experiment_index, ".rds"))) {
      rds_file <- readRDS(paste0("cache/binom", experiment_setup_index, "_", experiment_index, ".rds"))
      cp_set <- rds_file$cp_set
      time_used <- rds_file$time_used
    } else {
      start <- proc.time()
      if (sgd_k == 7) {
        cp_set <- CP_vanilla_binomial(data[, c(1:p + 1, 1)], beta)$cp
      } else if (sgd_k == 5) {
        logistic_regression_result <- fastcpd(
          data = data,
          beta = beta,
          family = "binomial",
          k = function(x, data_length = n) {
            if (x < data_length / 10 * 1 / 4) 5
            else if (x < data_length / 10 * 2 / 4) 3
            else if (x < data_length / 10 * 3 / 4) 1
            else 0
          },
          epsilon = 1e-5
        )
        cp_set <- logistic_regression_result@cp_set
      } else {
        logistic_regression_result <- fastcpd(
          data = data,
          beta = beta,
          family = "binomial",
          k = function(x) sgd_k - 1,
          epsilon = 1e-5
        )
        cp_set <- logistic_regression_result@cp_set
      }
      time_used <- unname((proc.time() - start)[3])
      saveRDS(list(data = data, cp_set = cp_set, time_used = time_used), paste0("cache/binom", experiment_setup_index, "_", experiment_index, ".rds"))
    }
    cp_gd <- cp_set[!(cp_set==0)]
    K_est <- length(cp_gd) + 1
    cp_un <- unique(c(0, cp_gd, n))
    g_est <- rep(1:K_est, diff(cp_un))
    c(fossil::rand.index(g_tr, g_est), time_used)
  }
parallel::stopCluster(cl)

experiment_setup_index <- 25
experiment_setup_row <- experiment_setup[experiment_setup_index, ]
n <- data_setup[experiment_setup$data_setup_index[experiment_setup_index], ]$n
p <- data_setup[experiment_setup$data_setup_index[experiment_setup_index], ]$p
change_points_count <- data_setup[experiment_setup$data_setup_index[experiment_setup_index], ]$change_points_count
sgd_k <- experiment_setup_row$sgd_k

if (p == 1) {
  theta_0 <- 1.2
} else {
  theta_0 <- c(1, 1.2, -1, 0.5, -2)[seq_len(p)]
}

true.coef <- matrix(rep(theta_0, change_points_count + 1), nrow = p, ncol = change_points_count + 1)

theta_norm <- c(0.36, NA, 0.81, NA, 1.96)[p]
delta <- rnorm(p)
sigma_ <- 0.9**abs(row(diag(p)) - col(diag(p)))
delta_coef <- sqrt(theta_norm / t(delta) %*% sigma_ %*% delta)

true.cp.loc <- sort(sample.int(n - 1, change_points_count, replace = FALSE))
if (change_points_count == 1) {
  true.coef[, 2] <- theta_0 + c(delta_coef) * delta
} else if (change_points_count == 3) {
  true.coef[, 2] <- theta_0 + c(delta_coef) * delta
  true.coef[, 4] <- theta_0 - c(delta_coef) * delta
} else if (change_points_count == 5) {
  true.coef[, 2] <- theta_0 + c(delta_coef) * delta
  true.coef[, 4] <- theta_0 - c(delta_coef) * delta
  true.coef[, 6] <- theta_0 + c(delta_coef) * delta
}

Sigma <- diag(1, p)
evar <- 0.5
out <- data_gen_binom(n, p, true.coef, true.cp.loc, Sigma, evar)
data <- out[[1]]
g_tr <- out[[2]]
beta <- log(n)/2
logistic_regression_result <- fastcpd(
  data = data,
  beta = beta,
  family = "binomial",
  k = function(x) 0,
  epsilon = 1e-5
)
@
<<logistic regression plot, fig=TRUE, height=5.2, width=7>>=
summary(logistic_regression_result)
plot(logistic_regression_result)
@

\newgeometry{margin=1cm}
\begin{landscape}

  \begin{table}[t!]
    \centering
    \begin{tabular}{@{}cccccccccc@{}}
    \toprule
                           & \multicolumn{3}{c}{p=1}                                            & \multicolumn{3}{c}{p=3}                                            & \multicolumn{3}{c}{p=5}                                            \\
                           & n=300                & n=600                & n=1500               & n=300                & n=600                & n=1500               & n=300                & n=600                & n=1500               \\ \midrule
    \multirow{4}{*}{cpc=0} & \Sexpr{get_result(300, 1, 0, 1)} & \Sexpr{get_result(600, 1, 0, 1)} & \Sexpr{get_result(1500, 1, 0, 1)} & \Sexpr{get_result(300, 3, 0, 1)} & \Sexpr{get_result(600, 3, 0, 1)} & \Sexpr{get_result(1500, 3, 0, 1)} & \Sexpr{get_result(300, 5, 0, 1)} & \Sexpr{get_result(600, 5, 0, 1)} & \Sexpr{get_result(1500, 5, 0, 1)} \\
                           & \Sexpr{get_result(300, 1, 0, 2)} & \Sexpr{get_result(600, 1, 0, 2)} & \Sexpr{get_result(1500, 1, 0, 2)} & \Sexpr{get_result(300, 3, 0, 2)} & \Sexpr{get_result(600, 3, 0, 2)} & \Sexpr{get_result(1500, 3, 0, 2)} & \Sexpr{get_result(300, 5, 0, 2)} & \Sexpr{get_result(600, 5, 0, 2)} & \Sexpr{get_result(1500, 5, 0, 2)} \\
                           & \Sexpr{get_result(300, 1, 0, 3)} & \Sexpr{get_result(600, 1, 0, 3)} & \Sexpr{get_result(1500, 1, 0, 3)} & \Sexpr{get_result(300, 3, 0, 3)} & \Sexpr{get_result(600, 3, 0, 3)} & \Sexpr{get_result(1500, 3, 0, 3)} & \Sexpr{get_result(300, 5, 0, 3)} & \Sexpr{get_result(600, 5, 0, 3)} & \Sexpr{get_result(1500, 5, 0, 3)} \\
                           & \Sexpr{get_result(300, 1, 0, 5)} & \Sexpr{get_result(600, 1, 0, 5)} & \Sexpr{get_result(1500, 1, 0, 5)} & \Sexpr{get_result(300, 3, 0, 5)} & \Sexpr{get_result(600, 3, 0, 5)} & \Sexpr{get_result(1500, 3, 0, 5)} & \Sexpr{get_result(300, 5, 0, 5)} & \Sexpr{get_result(600, 5, 0, 5)} & \Sexpr{get_result(1500, 5, 0, 5)} \\
                           & \Sexpr{get_result(300, 1, 0, 7)} & \Sexpr{get_result(600, 1, 0, 7)} & \Sexpr{get_result(1500, 1, 0, 7)} & \Sexpr{get_result(300, 3, 0, 7)} & \Sexpr{get_result(600, 3, 0, 7)} & \Sexpr{get_result(1500, 3, 0, 7)} & \Sexpr{get_result(300, 5, 0, 7)} & \Sexpr{get_result(600, 5, 0, 7)} & \Sexpr{get_result(1500, 5, 0, 7)} \\ \midrule
    \multirow{4}{*}{cpc=1} & \Sexpr{get_result(300, 1, 1, 1)} & \Sexpr{get_result(600, 1, 1, 1)} & \Sexpr{get_result(1500, 1, 1, 1)} & \Sexpr{get_result(300, 3, 1, 1)} & \Sexpr{get_result(600, 3, 1, 1)} & \Sexpr{get_result(1500, 3, 1, 1)} & \Sexpr{get_result(300, 5, 1, 1)} & \Sexpr{get_result(600, 5, 1, 1)} & \Sexpr{get_result(1500, 5, 1, 1)} \\
                           & \Sexpr{get_result(300, 1, 1, 2)} & \Sexpr{get_result(600, 1, 1, 2)} & \Sexpr{get_result(1500, 1, 1, 2)} & \Sexpr{get_result(300, 3, 1, 2)} & \Sexpr{get_result(600, 3, 1, 2)} & \Sexpr{get_result(1500, 3, 1, 2)} & \Sexpr{get_result(300, 5, 1, 2)} & \Sexpr{get_result(600, 5, 1, 2)} & \Sexpr{get_result(1500, 5, 1, 2)} \\
                           & \Sexpr{get_result(300, 1, 1, 3)} & \Sexpr{get_result(600, 1, 1, 3)} & \Sexpr{get_result(1500, 1, 1, 3)} & \Sexpr{get_result(300, 3, 1, 3)} & \Sexpr{get_result(600, 3, 1, 3)} & \Sexpr{get_result(1500, 3, 1, 3)} & \Sexpr{get_result(300, 5, 1, 3)} & \Sexpr{get_result(600, 5, 1, 3)} & \Sexpr{get_result(1500, 5, 1, 3)} \\
                           & \Sexpr{get_result(300, 1, 1, 5)} & \Sexpr{get_result(600, 1, 1, 5)} & \Sexpr{get_result(1500, 1, 1, 5)} & \Sexpr{get_result(300, 3, 1, 5)} & \Sexpr{get_result(600, 3, 1, 5)} & \Sexpr{get_result(1500, 3, 1, 5)} & \Sexpr{get_result(300, 5, 1, 5)} & \Sexpr{get_result(600, 5, 1, 5)} & \Sexpr{get_result(1500, 5, 1, 5)} \\
                           & \Sexpr{get_result(300, 1, 1, 7)} & \Sexpr{get_result(600, 1, 1, 7)} & \Sexpr{get_result(1500, 1, 1, 7)} & \Sexpr{get_result(300, 3, 1, 7)} & \Sexpr{get_result(600, 3, 1, 7)} & \Sexpr{get_result(1500, 3, 1, 7)} & \Sexpr{get_result(300, 5, 1, 7)} & \Sexpr{get_result(600, 5, 1, 7)} & \Sexpr{get_result(1500, 5, 1, 7)} \\ \midrule
    \multirow{4}{*}{cpc=3} & \Sexpr{get_result(300, 1, 3, 1)} & \Sexpr{get_result(600, 1, 3, 1)} & \Sexpr{get_result(1500, 1, 3, 1)} & \Sexpr{get_result(300, 3, 3, 1)} & \Sexpr{get_result(600, 3, 3, 1)} & \Sexpr{get_result(1500, 3, 3, 1)} & \Sexpr{get_result(300, 5, 3, 1)} & \Sexpr{get_result(600, 5, 3, 1)} & \Sexpr{get_result(1500, 5, 3, 1)} \\
                           & \Sexpr{get_result(300, 1, 3, 2)} & \Sexpr{get_result(600, 1, 3, 2)} & \Sexpr{get_result(1500, 1, 3, 2)} & \Sexpr{get_result(300, 3, 3, 2)} & \Sexpr{get_result(600, 3, 3, 2)} & \Sexpr{get_result(1500, 3, 3, 2)} & \Sexpr{get_result(300, 5, 3, 2)} & \Sexpr{get_result(600, 5, 3, 2)} & \Sexpr{get_result(1500, 5, 3, 2)} \\
                           & \Sexpr{get_result(300, 1, 3, 3)} & \Sexpr{get_result(600, 1, 3, 3)} & \Sexpr{get_result(1500, 1, 3, 3)} & \Sexpr{get_result(300, 3, 3, 3)} & \Sexpr{get_result(600, 3, 3, 3)} & \Sexpr{get_result(1500, 3, 3, 3)} & \Sexpr{get_result(300, 5, 3, 3)} & \Sexpr{get_result(600, 5, 3, 3)} & \Sexpr{get_result(1500, 5, 3, 3)} \\
                           & \Sexpr{get_result(300, 1, 3, 5)} & \Sexpr{get_result(600, 1, 3, 5)} & \Sexpr{get_result(1500, 1, 3, 5)} & \Sexpr{get_result(300, 3, 3, 5)} & \Sexpr{get_result(600, 3, 3, 5)} & \Sexpr{get_result(1500, 3, 3, 5)} & \Sexpr{get_result(300, 5, 3, 5)} & \Sexpr{get_result(600, 5, 3, 5)} & \Sexpr{get_result(1500, 5, 3, 5)} \\
                           & \Sexpr{get_result(300, 1, 3, 7)} & \Sexpr{get_result(600, 1, 3, 7)} & \Sexpr{get_result(1500, 1, 3, 7)} & \Sexpr{get_result(300, 3, 3, 7)} & \Sexpr{get_result(600, 3, 3, 7)} & \Sexpr{get_result(1500, 3, 3, 7)} & \Sexpr{get_result(300, 5, 3, 7)} & \Sexpr{get_result(600, 5, 3, 7)} & \Sexpr{get_result(1500, 5, 3, 7)} \\ \midrule
    \multirow{4}{*}{cpc=5} & \Sexpr{get_result(300, 1, 5, 1)} & \Sexpr{get_result(600, 1, 5, 1)} & \Sexpr{get_result(1500, 1, 5, 1)} & \Sexpr{get_result(300, 3, 5, 1)} & \Sexpr{get_result(600, 3, 5, 1)} & \Sexpr{get_result(1500, 3, 5, 1)} & \Sexpr{get_result(300, 5, 5, 1)} & \Sexpr{get_result(600, 5, 5, 1)} & \Sexpr{get_result(1500, 5, 5, 1)} \\
                           & \Sexpr{get_result(300, 1, 5, 2)} & \Sexpr{get_result(600, 1, 5, 2)} & \Sexpr{get_result(1500, 1, 5, 2)} & \Sexpr{get_result(300, 3, 5, 2)} & \Sexpr{get_result(600, 3, 5, 2)} & \Sexpr{get_result(1500, 3, 5, 2)} & \Sexpr{get_result(300, 5, 5, 2)} & \Sexpr{get_result(600, 5, 5, 2)} & \Sexpr{get_result(1500, 5, 5, 2)} \\
                           & \Sexpr{get_result(300, 1, 5, 3)} & \Sexpr{get_result(600, 1, 5, 3)} & \Sexpr{get_result(1500, 1, 5, 3)} & \Sexpr{get_result(300, 3, 5, 3)} & \Sexpr{get_result(600, 3, 5, 3)} & \Sexpr{get_result(1500, 3, 5, 3)} & \Sexpr{get_result(300, 5, 5, 3)} & \Sexpr{get_result(600, 5, 5, 3)} & \Sexpr{get_result(1500, 5, 5, 3)} \\
                           & \Sexpr{get_result(300, 1, 5, 5)} & \Sexpr{get_result(600, 1, 5, 5)} & \Sexpr{get_result(1500, 1, 5, 5)} & \Sexpr{get_result(300, 3, 5, 5)} & \Sexpr{get_result(600, 3, 5, 5)} & \Sexpr{get_result(1500, 3, 5, 5)} & \Sexpr{get_result(300, 5, 5, 5)} & \Sexpr{get_result(600, 5, 5, 5)} & \Sexpr{get_result(1500, 5, 5, 5)} \\
                           & \Sexpr{get_result(300, 1, 5, 7)} & \Sexpr{get_result(600, 1, 5, 7)} & \Sexpr{get_result(1500, 1, 5, 7)} & \Sexpr{get_result(300, 3, 5, 7)} & \Sexpr{get_result(600, 3, 5, 7)} & \Sexpr{get_result(1500, 3, 5, 7)} & \Sexpr{get_result(300, 5, 5, 7)} & \Sexpr{get_result(600, 5, 5, 7)} & \Sexpr{get_result(1500, 5, 5, 7)} \\ \bottomrule
    \end{tabular}
    \caption{\label{tab:logistic regression comparison} Comparison of the algorithms for the logistic regression model in mean.}
  \end{table}

\end{landscape}
\restoregeometry

\section{Changes in generalized linear models: Poisson regression} \label{sec:poisson}

We now consider the change-point detection problem in the Poisson Regression
setting. Suppose we have a data set containing a set of
predictors/covariates and corresponding response variables, i.e. each data point
\code{data[i, ]} contains a set of predictors/covariates \code{data[i, -1]} and
a response \code{data[i, 1]}. The reason we set the first column to be the
response variables are that in \proglang{R}, we can use \code{-1} to denote all
columns other than the first column without the need to consider number of
columns altogether.

Suppose the response variables follows a poisson distribution with specifics
defined as
%
\begin{equation} \label{eq:logistic_regression}
y_i \sim \mathrm{Poisson}\left(e^{x_i^\top \theta_i}\right),
\quad x_i \sim \mathcal{N}_p(0, \Sigma)\ \mathrm{with}\ \Sigma =
(0.9^{\lvert i - j \rvert})_{p \times p}, \quad 1 \le i \le n,
\end{equation}
%
where $\{y_i\}$ is the response variable, $\{x_i\}$ is the covariate vector,
$\Sigma$ is the covariance matrix for the sampling of $\{x_i\}$, $p$ is the
number of predictors, $n$ is the total number of data points.

We now use the \pkg{fastcpd} package to detect the change points in the data set
\code{data}. During the simulations, we vary the number of data points in
$\{300, 500, 1500\}$ and the dimensions $p$ to $\{1, 3, 5\}$ while varying $\theta_i$
to produce different magnitudes of change. We define $\delta_p$ as the difference
between the coefficients before and after a change-point and selected its value
such that $M(\delta_p):=\delta_p^\top \Sigma \delta_p \in \{0.36, 0.81, 1.96\}$,
representing small, medium, and large magnitudes of change, respectively. The
specific choice of $\delta_p$ does not affect the results as long as $M(\delta_p)$
is consistent. We evaluated the number of change-points at 0, 1, 3, and 5 for
each configuration, and the detailed simulation settings for each case are given
below.
%
<<poisson regression, echo=FALSE>>=
data_gen_poisson <- function(n, p, true.coef, true.cp.loc, Sigma, evar) {
  loc <- unique(c(0, true.cp.loc, n))
  if(dim(true.coef)[2] != length(loc)-1) stop("true.coef and true.cp.loc do not match")
  x <- mvtnorm::rmvnorm(n, mean = rep(0, p), sigma = Sigma)
  y <- NULL
  for(i in 1:(length(loc)-1))
  {
    Xb <- x[(loc[i] + 1):loc[i + 1], ,drop=FALSE]%*%true.coef[,i,drop=FALSE]
    y <- c(y, rpois(loc[i + 1] - loc[i], exp(Xb)))
  }
  data <- cbind(y, x)
  true_cluster <- rep(1:(length(loc)-1), diff(loc))
  result <- list(data, true_cluster)
  return(result)
}

cost_glm_poisson <- function(data, family="poisson")
{
data <- as.matrix(data)
p <- dim(data)[2] - 1
out <- fastglm(as.matrix(data[,1:p]), data[,p+1], family=family)
if (!out$converged) {
  return(0)
}
return(out$deviance/2)
}

CP_vanilla_poisson <- function(data, beta, cost=cost_glm_poisson, trim = 0.025)
{
n <- dim(data)[1]
p <- dim(data)[2] - 1
Fobj <- c(-beta, 0)
cp_set <- list(NULL,0)
set <- c(0,1)
 for(t in 2:n)
 {
 m <- length(set)
 cval <- rep(NA, m)
  for(i in 1:m)
  {
  k <- set[i] + 1
  cval[i] <- 0
  if(t-k>=p-1) cval[i] <- suppressWarnings(cost(data[k:t,, drop = FALSE]))
  }
 obj <- cval + Fobj[set+1] + beta
 min_val <- min(obj)
 ind <- which(obj==min_val)[1]
 cp_set_add <- c(cp_set[[set[ind]+1]], set[ind])
 cp_set <- append(cp_set,list(cp_set_add))
 ind2 <- (cval + Fobj[set+1]) <= min_val
 set <- c(set[ind2], t)
 Fobj <- c(Fobj, min_val)
 }
cp <- cp_set[[n+1]]
nLL <- 0

cp <- cp[(cp >= trim * n) & (cp <= (1 - trim) * n)]
cp <- sort(unique(c(0, cp)))

segment_indices <- which((diff(cp) < trim * n) == TRUE)
if (length(segment_indices) > 0) {
  cp <- floor(
    (cp[-(segment_indices + 1)] + cp[-segment_indices]) / 2
  )
}
cp_loc <- unique(c(0,cp,n))
for(i in 1:(length(cp_loc)-1))
 {
 seg <- (cp_loc[i]+1):cp_loc[i+1]
 data_seg <- data[seg,]
 out <- fastglm(as.matrix(data_seg[, 1:p]), data_seg[, p+1], family="poisson")
 nLL <- out$deviance/2 + nLL
 }

output <- list(cp, nLL)
names(output) <- c("cp", "nLL")
return(output)
}
data_setup <- purrr::cross_df(
  list(
    n = c(300, 600, 1500),
    p = c(1, 3, 5),
    change_points_count = c(0, 1, 3, 5)
  )
)

experiment_setup <- purrr::cross_df(
  list(
    data_setup_index = seq_len(nrow(data_setup)),
    sgd_k = c(1, 2, 3, 5, 7)
  )
)
experiment_num <- 100

rand_gd <- time_gd <- rep(list(rep(NA, experiment_num)), nrow(experiment_setup))
rng <- RNGseq(experiment_num * nrow(data_setup), 3)

cl <- parallel::makeCluster(parallel::detectCores(), outfile = paste0("log/poisson.log"))
doParallel::registerDoParallel(cl)
experiment_result <- foreach::foreach(experiment_setup_index = seq_len(nrow(experiment_setup)), .packages = c("fastglm", "fastcpd", "fossil", "glmnet")) %:%
  foreach::foreach(experiment_index = seq_len(experiment_num), rrng = rng[(experiment_setup$data_setup_index[experiment_setup_index] - 1) * experiment_num + seq_len(experiment_num)], .combine = "rbind") %dopar% {
    rngtools::setRNG(rrng)
    experiment_setup_row <- experiment_setup[experiment_setup_index, ]
    n <- data_setup[experiment_setup$data_setup_index[experiment_setup_index], ]$n
    p <- data_setup[experiment_setup$data_setup_index[experiment_setup_index], ]$p
    change_points_count <- data_setup[experiment_setup$data_setup_index[experiment_setup_index], ]$change_points_count
    sgd_k <- experiment_setup_row$sgd_k

    if (p == 1) {
      theta_0 <- 1.2
    } else {
      theta_0 <- c(1, 1.2, -1, 0.5, -2)[seq_len(p)]
    }

    true.coef <- matrix(rep(theta_0, change_points_count + 1), nrow = p, ncol = change_points_count + 1)

    theta_norm <- c(0.36, NA, 0.81, NA, 1.96)[p]
    delta <- rnorm(p)
    sigma_ <- 0.9**abs(row(diag(p)) - col(diag(p)))
    delta_coef <- sqrt(theta_norm / t(delta) %*% sigma_ %*% delta)

    true.cp.loc <- sort(sample.int(n - 1, change_points_count, replace = FALSE))
    if (change_points_count == 1) {
      true.coef[, 2] <- theta_0 + c(delta_coef) * delta
    } else if (change_points_count == 3) {
      true.coef[, 2] <- theta_0 + c(delta_coef) * delta
      true.coef[, 4] <- theta_0 - c(delta_coef) * delta
    } else if (change_points_count == 5) {
      true.coef[, 2] <- theta_0 + c(delta_coef) * delta
      true.coef[, 4] <- theta_0 - c(delta_coef) * delta
      true.coef[, 6] <- theta_0 + c(delta_coef) * delta
    }

    Sigma <- diag(1, p)
    evar <- 0.5
    out <- data_gen_poisson(n, p, true.coef, true.cp.loc, Sigma, evar)
    data <- out[[1]]
    g_tr <- out[[2]]
    beta <- log(n)/2

    if (file.exists(paste0("cache/poisson", experiment_setup_index, "_", experiment_index, ".rds"))) {
      rds_file <- readRDS(paste0("cache/poisson", experiment_setup_index, "_", experiment_index, ".rds"))
      cp_set <- rds_file$cp_set
      time_used <- rds_file$time_used
    } else {
      start <- proc.time()
      if (sgd_k == 7) {
        cp_set <- CP_vanilla_poisson(data[, c(1:p + 1, 1)], beta)$cp
      } else if (sgd_k == 5) {
        poisson_regression_result <- tryCatch(
            fastcpd(
            data = data,
            beta = beta,
            family = "poisson",
            k = function(x, data_length = n) {
              if (x < data_length / 10 * 1 / 4) 5
              else if (x < data_length / 10 * 2 / 4) 3
              else if (x < data_length / 10 * 3 / 4) 1
              else 0
            },
            epsilon = 1e-5
          ),
          error = function(e1) {
            tryCatch(
              fastcpd(
                data = data,
                beta = beta,
                family = "poisson",
                k = function(x, data_length = n) {
                  if (x < data_length / 10 * 1 / 4) 5
                  else if (x < data_length / 10 * 2 / 4) 3
                  else if (x < data_length / 10 * 3 / 4) 1
                  else 0
                },
                epsilon = 1e-4
              ),
              error = function(e2) {
                tryCatch(
                  fastcpd(
                    data = data,
                    beta = beta,
                    family = "poisson",
                    k = function(x, data_length = n) {
                      if (x < data_length / 10 * 1 / 4) 5
                      else if (x < data_length / 10 * 2 / 4) 3
                      else if (x < data_length / 10 * 3 / 4) 1
                      else 0
                    },
                    epsilon = 1e-3
                  ),
                  error = function(e3) {
                    fastcpd(
                      data = data,
                      beta = beta,
                      family = "poisson",
                      k = function(x, data_length = n) {
                        if (x < data_length / 10 * 1 / 4) 5
                        else if (x < data_length / 10 * 2 / 4) 3
                        else if (x < data_length / 10 * 3 / 4) 1
                        else 0
                      },
                      epsilon = 1e-2
                    )
                  }
                )
              }
            )
          }
        )
        cp_set <- poisson_regression_result@cp_set
      } else {
        poisson_regression_result <- tryCatch(
            fastcpd(
            data = data,
            beta = beta,
            family = "poisson",
            k = function(x) sgd_k - 1,
            epsilon = 1e-5
          ),
          error = function(e1) {
            tryCatch(
              fastcpd(
                data = data,
                beta = beta,
                family = "poisson",
                k = function(x) sgd_k - 1,
                epsilon = 1e-4
              ),
              error = function(e2) {
                tryCatch(
                  fastcpd(
                    data = data,
                    beta = beta,
                    family = "poisson",
                    k = function(x) sgd_k - 1,
                    epsilon = 1e-3
                  ),
                  error = function(e3) {
                    fastcpd(
                      data = data,
                      beta = beta,
                      family = "poisson",
                      k = function(x) sgd_k - 1,
                      epsilon = 1e-2
                    )
                  }
                )
              }
            )
          }
        )
        cp_set <- poisson_regression_result@cp_set
      }
      time_used <- unname((proc.time() - start)[3])
      saveRDS(list(data = data, cp_set = cp_set, time_used = time_used), paste0("cache/poisson", experiment_setup_index, "_", experiment_index, ".rds"))
    }
    cp_gd <- cp_set[!(cp_set==0)]
    K_est <- length(cp_gd) + 1
    cp_un <- unique(c(0, cp_gd, n))
    g_est <- rep(1:K_est, diff(cp_un))
    c(fossil::rand.index(g_tr, g_est), time_used)
  }
parallel::stopCluster(cl)

experiment_setup_index <- 25
experiment_setup_row <- experiment_setup[experiment_setup_index, ]
n <- data_setup[experiment_setup$data_setup_index[experiment_setup_index], ]$n
p <- data_setup[experiment_setup$data_setup_index[experiment_setup_index], ]$p
change_points_count <- data_setup[experiment_setup$data_setup_index[experiment_setup_index], ]$change_points_count
sgd_k <- experiment_setup_row$sgd_k

if (p == 1) {
  theta_0 <- 1.2
} else {
  theta_0 <- c(1, 1.2, -1, 0.5, -2)[seq_len(p)]
}

true.coef <- matrix(rep(theta_0, change_points_count + 1), nrow = p, ncol = change_points_count + 1)

theta_norm <- c(0.36, NA, 0.81, NA, 1.96)[p]
delta <- rnorm(p)
sigma_ <- 0.9**abs(row(diag(p)) - col(diag(p)))
delta_coef <- sqrt(theta_norm / t(delta) %*% sigma_ %*% delta)

true.cp.loc <- sort(sample.int(n - 1, change_points_count, replace = FALSE))
if (change_points_count == 1) {
  true.coef[, 2] <- theta_0 + c(delta_coef) * delta
} else if (change_points_count == 3) {
  true.coef[, 2] <- theta_0 + c(delta_coef) * delta
  true.coef[, 4] <- theta_0 - c(delta_coef) * delta
} else if (change_points_count == 5) {
  true.coef[, 2] <- theta_0 + c(delta_coef) * delta
  true.coef[, 4] <- theta_0 - c(delta_coef) * delta
  true.coef[, 6] <- theta_0 + c(delta_coef) * delta
}

Sigma <- diag(1, p)
evar <- 0.5
out <- data_gen_poisson(n, p, true.coef, true.cp.loc, Sigma, evar)
data <- out[[1]]
g_tr <- out[[2]]
beta <- log(n)/2
poisson_regression_result <- fastcpd(
  data = data,
  beta = beta,
  family = "poisson",
  k = function(x) 0,
  epsilon = 1e-4
)
@
%

<<poisson regression plot, fig=TRUE, height=5.2, width=7>>=
summary(poisson_regression_result)
plot(poisson_regression_result)
@

\newgeometry{margin=1cm}
\begin{landscape}

  \begin{table}[t!]
    \centering
    \begin{tabular}{@{}cccccccccc@{}}
    \toprule
                           & \multicolumn{3}{c}{p=1}                                            & \multicolumn{3}{c}{p=3}                                            & \multicolumn{3}{c}{p=5}                                            \\
                           & n=300                & n=600                & n=1500               & n=300                & n=600                & n=1500               & n=300                & n=600                & n=1500               \\ \midrule
    \multirow{4}{*}{cpc=0} & \Sexpr{get_result(300, 1, 0, 1)} & \Sexpr{get_result(600, 1, 0, 1)} & \Sexpr{get_result(1500, 1, 0, 1)} & \Sexpr{get_result(300, 3, 0, 1)} & \Sexpr{get_result(600, 3, 0, 1)} & \Sexpr{get_result(1500, 3, 0, 1)} & \Sexpr{get_result(300, 5, 0, 1)} & \Sexpr{get_result(600, 5, 0, 1)} & \Sexpr{get_result(1500, 5, 0, 1)} \\
                           & \Sexpr{get_result(300, 1, 0, 2)} & \Sexpr{get_result(600, 1, 0, 2)} & \Sexpr{get_result(1500, 1, 0, 2)} & \Sexpr{get_result(300, 3, 0, 2)} & \Sexpr{get_result(600, 3, 0, 2)} & \Sexpr{get_result(1500, 3, 0, 2)} & \Sexpr{get_result(300, 5, 0, 2)} & \Sexpr{get_result(600, 5, 0, 2)} & \Sexpr{get_result(1500, 5, 0, 2)} \\
                           & \Sexpr{get_result(300, 1, 0, 3)} & \Sexpr{get_result(600, 1, 0, 3)} & \Sexpr{get_result(1500, 1, 0, 3)} & \Sexpr{get_result(300, 3, 0, 3)} & \Sexpr{get_result(600, 3, 0, 3)} & \Sexpr{get_result(1500, 3, 0, 3)} & \Sexpr{get_result(300, 5, 0, 3)} & \Sexpr{get_result(600, 5, 0, 3)} & \Sexpr{get_result(1500, 5, 0, 3)} \\
                           & \Sexpr{get_result(300, 1, 0, 5)} & \Sexpr{get_result(600, 1, 0, 5)} & \Sexpr{get_result(1500, 1, 0, 5)} & \Sexpr{get_result(300, 3, 0, 5)} & \Sexpr{get_result(600, 3, 0, 5)} & \Sexpr{get_result(1500, 3, 0, 5)} & \Sexpr{get_result(300, 5, 0, 5)} & \Sexpr{get_result(600, 5, 0, 5)} & \Sexpr{get_result(1500, 5, 0, 5)} \\
                           & \Sexpr{get_result(300, 1, 0, 7)} & \Sexpr{get_result(600, 1, 0, 7)} & \Sexpr{get_result(1500, 1, 0, 7)} & \Sexpr{get_result(300, 3, 0, 7)} & \Sexpr{get_result(600, 3, 0, 7)} & \Sexpr{get_result(1500, 3, 0, 7)} & \Sexpr{get_result(300, 5, 0, 7)} & \Sexpr{get_result(600, 5, 0, 7)} & \Sexpr{get_result(1500, 5, 0, 7)} \\ \midrule
    \multirow{4}{*}{cpc=1} & \Sexpr{get_result(300, 1, 1, 1)} & \Sexpr{get_result(600, 1, 1, 1)} & \Sexpr{get_result(1500, 1, 1, 1)} & \Sexpr{get_result(300, 3, 1, 1)} & \Sexpr{get_result(600, 3, 1, 1)} & \Sexpr{get_result(1500, 3, 1, 1)} & \Sexpr{get_result(300, 5, 1, 1)} & \Sexpr{get_result(600, 5, 1, 1)} & \Sexpr{get_result(1500, 5, 1, 1)} \\
                           & \Sexpr{get_result(300, 1, 1, 2)} & \Sexpr{get_result(600, 1, 1, 2)} & \Sexpr{get_result(1500, 1, 1, 2)} & \Sexpr{get_result(300, 3, 1, 2)} & \Sexpr{get_result(600, 3, 1, 2)} & \Sexpr{get_result(1500, 3, 1, 2)} & \Sexpr{get_result(300, 5, 1, 2)} & \Sexpr{get_result(600, 5, 1, 2)} & \Sexpr{get_result(1500, 5, 1, 2)} \\
                           & \Sexpr{get_result(300, 1, 1, 3)} & \Sexpr{get_result(600, 1, 1, 3)} & \Sexpr{get_result(1500, 1, 1, 3)} & \Sexpr{get_result(300, 3, 1, 3)} & \Sexpr{get_result(600, 3, 1, 3)} & \Sexpr{get_result(1500, 3, 1, 3)} & \Sexpr{get_result(300, 5, 1, 3)} & \Sexpr{get_result(600, 5, 1, 3)} & \Sexpr{get_result(1500, 5, 1, 3)} \\
                           & \Sexpr{get_result(300, 1, 1, 5)} & \Sexpr{get_result(600, 1, 1, 5)} & \Sexpr{get_result(1500, 1, 1, 5)} & \Sexpr{get_result(300, 3, 1, 5)} & \Sexpr{get_result(600, 3, 1, 5)} & \Sexpr{get_result(1500, 3, 1, 5)} & \Sexpr{get_result(300, 5, 1, 5)} & \Sexpr{get_result(600, 5, 1, 5)} & \Sexpr{get_result(1500, 5, 1, 5)} \\
                           & \Sexpr{get_result(300, 1, 1, 7)} & \Sexpr{get_result(600, 1, 1, 7)} & \Sexpr{get_result(1500, 1, 1, 7)} & \Sexpr{get_result(300, 3, 1, 7)} & \Sexpr{get_result(600, 3, 1, 7)} & \Sexpr{get_result(1500, 3, 1, 7)} & \Sexpr{get_result(300, 5, 1, 7)} & \Sexpr{get_result(600, 5, 1, 7)} & \Sexpr{get_result(1500, 5, 1, 7)} \\ \midrule
    \multirow{4}{*}{cpc=3} & \Sexpr{get_result(300, 1, 3, 1)} & \Sexpr{get_result(600, 1, 3, 1)} & \Sexpr{get_result(1500, 1, 3, 1)} & \Sexpr{get_result(300, 3, 3, 1)} & \Sexpr{get_result(600, 3, 3, 1)} & \Sexpr{get_result(1500, 3, 3, 1)} & \Sexpr{get_result(300, 5, 3, 1)} & \Sexpr{get_result(600, 5, 3, 1)} & \Sexpr{get_result(1500, 5, 3, 1)} \\
                           & \Sexpr{get_result(300, 1, 3, 2)} & \Sexpr{get_result(600, 1, 3, 2)} & \Sexpr{get_result(1500, 1, 3, 2)} & \Sexpr{get_result(300, 3, 3, 2)} & \Sexpr{get_result(600, 3, 3, 2)} & \Sexpr{get_result(1500, 3, 3, 2)} & \Sexpr{get_result(300, 5, 3, 2)} & \Sexpr{get_result(600, 5, 3, 2)} & \Sexpr{get_result(1500, 5, 3, 2)} \\
                           & \Sexpr{get_result(300, 1, 3, 3)} & \Sexpr{get_result(600, 1, 3, 3)} & \Sexpr{get_result(1500, 1, 3, 3)} & \Sexpr{get_result(300, 3, 3, 3)} & \Sexpr{get_result(600, 3, 3, 3)} & \Sexpr{get_result(1500, 3, 3, 3)} & \Sexpr{get_result(300, 5, 3, 3)} & \Sexpr{get_result(600, 5, 3, 3)} & \Sexpr{get_result(1500, 5, 3, 3)} \\
                           & \Sexpr{get_result(300, 1, 3, 5)} & \Sexpr{get_result(600, 1, 3, 5)} & \Sexpr{get_result(1500, 1, 3, 5)} & \Sexpr{get_result(300, 3, 3, 5)} & \Sexpr{get_result(600, 3, 3, 5)} & \Sexpr{get_result(1500, 3, 3, 5)} & \Sexpr{get_result(300, 5, 3, 5)} & \Sexpr{get_result(600, 5, 3, 5)} & \Sexpr{get_result(1500, 5, 3, 5)} \\
                           & \Sexpr{get_result(300, 1, 3, 7)} & \Sexpr{get_result(600, 1, 3, 7)} & \Sexpr{get_result(1500, 1, 3, 7)} & \Sexpr{get_result(300, 3, 3, 7)} & \Sexpr{get_result(600, 3, 3, 7)} & \Sexpr{get_result(1500, 3, 3, 7)} & \Sexpr{get_result(300, 5, 3, 7)} & \Sexpr{get_result(600, 5, 3, 7)} & \Sexpr{get_result(1500, 5, 3, 7)} \\ \midrule
    \multirow{4}{*}{cpc=5} & \Sexpr{get_result(300, 1, 5, 1)} & \Sexpr{get_result(600, 1, 5, 1)} & \Sexpr{get_result(1500, 1, 5, 1)} & \Sexpr{get_result(300, 3, 5, 1)} & \Sexpr{get_result(600, 3, 5, 1)} & \Sexpr{get_result(1500, 3, 5, 1)} & \Sexpr{get_result(300, 5, 5, 1)} & \Sexpr{get_result(600, 5, 5, 1)} & \Sexpr{get_result(1500, 5, 5, 1)} \\
                           & \Sexpr{get_result(300, 1, 5, 2)} & \Sexpr{get_result(600, 1, 5, 2)} & \Sexpr{get_result(1500, 1, 5, 2)} & \Sexpr{get_result(300, 3, 5, 2)} & \Sexpr{get_result(600, 3, 5, 2)} & \Sexpr{get_result(1500, 3, 5, 2)} & \Sexpr{get_result(300, 5, 5, 2)} & \Sexpr{get_result(600, 5, 5, 2)} & \Sexpr{get_result(1500, 5, 5, 2)} \\
                           & \Sexpr{get_result(300, 1, 5, 3)} & \Sexpr{get_result(600, 1, 5, 3)} & \Sexpr{get_result(1500, 1, 5, 3)} & \Sexpr{get_result(300, 3, 5, 3)} & \Sexpr{get_result(600, 3, 5, 3)} & \Sexpr{get_result(1500, 3, 5, 3)} & \Sexpr{get_result(300, 5, 5, 3)} & \Sexpr{get_result(600, 5, 5, 3)} & \Sexpr{get_result(1500, 5, 5, 3)} \\
                           & \Sexpr{get_result(300, 1, 5, 5)} & \Sexpr{get_result(600, 1, 5, 5)} & \Sexpr{get_result(1500, 1, 5, 5)} & \Sexpr{get_result(300, 3, 5, 5)} & \Sexpr{get_result(600, 3, 5, 5)} & \Sexpr{get_result(1500, 3, 5, 5)} & \Sexpr{get_result(300, 5, 5, 5)} & \Sexpr{get_result(600, 5, 5, 5)} & \Sexpr{get_result(1500, 5, 5, 5)} \\
                           & \Sexpr{get_result(300, 1, 5, 7)} & \Sexpr{get_result(600, 1, 5, 7)} & \Sexpr{get_result(1500, 1, 5, 7)} & \Sexpr{get_result(300, 3, 5, 7)} & \Sexpr{get_result(600, 3, 5, 7)} & \Sexpr{get_result(1500, 3, 5, 7)} & \Sexpr{get_result(300, 5, 5, 7)} & \Sexpr{get_result(600, 5, 5, 7)} & \Sexpr{get_result(1500, 5, 5, 7)} \\ \bottomrule
    \end{tabular}
    \caption{\label{tab:poisson regression comparison} Comparison of the algorithms for the poisson regression model in mean.}
  \end{table}

\end{landscape}
\restoregeometry

\section{Changes in penalized linear models} \label{sec:penalized linear model}

We now consider the change-point detection problem in the penalized linear
models. Suppose we have a data set containing a set of
predictors/covariates and corresponding response variables, i.e. each data point
\code{data[i, ]} contains a set of predictors/covariates \code{data[i, -1]} and
a response \code{data[i, 1]}. The reason we set the first column to be the
response variables are that in \proglang{R}, we can use \code{-1} to denote all
columns other than the first column without the need to consider number of
columns altogether.

Suppose the response variables follows a linear model with sparse coefficients.
%
\begin{equation} \label{eq:logistic_regression}
y_i = x_i^\top \theta_i + \epsilon_i,
\quad x_i \sim \mathcal{N}_p(0, \Sigma)\ \mathrm{with}\ \Sigma =
0.5I_{p \times p}, \quad \epsilon_i \sim \mathcal{N}(0, 0.5), \quad 1 \le i \le n,
\end{equation}
%
where $\{y_i\}$ is the response variable, $\{x_i\}$ is the covariate vector,
$\Sigma$ is the covariance matrix for the sampling of $\{x_i\}$, $p$ is the
number of predictors, $n$ is the total number of data points.

We now use the \pkg{fastcpd} package to detect the change points in the data set
\code{data}. During the simulations, we set the numeber of data points to be
1500 and the dimensions $p$ to be 50 while varying $\theta_i$
to produce different magnitudes of change. We define $\delta_p$ as the difference
between the coefficients before and after a change-point and selected its value
such that $M(\delta_p):=\delta_p^\top \Sigma \delta_p \in \{0.36, 0.81, 1.96\}$,
representing small, medium, and large magnitudes of change, respectively. The
specific choice of $\delta_p$ does not affect the results as long as $M(\delta_p)$
is consistent. We evaluated the number of change-points at 0, 1, 3, and 5 for
each configuration, and the detailed simulation settings for each case are given
below.
%
<<lasso, echo=FALSE>>=
cost_lasso <- function(data, lambda, family="gaussian")
{
  data <- as.matrix(data)
  n <- dim(data)[1]
  p <- dim(data)[2] - 1
  out <- glmnet(as.matrix(data[,1:p]), data[,p+1], family=family, lambda=lambda)
  return(deviance(out)/2)
}

CP_vanilla_lasso <- function(data, beta, B=10, cost=cost_lasso, family="gaussian", trim = 0.025)
{
  n <- dim(data)[1]
  p <- dim(data)[2] - 1
  index <- rep(1:B, rep(n/B,B))
  err_sd <- act_num <- rep(NA, B)
  for(i in 1:B)
  {
    cvfit <- glmnet::cv.glmnet(as.matrix(data[index==i,1:p]), data[index==i,p+1], family=family)
    coef <- coef(cvfit, s = "lambda.1se")[-1]
    resi <- data[index==i,p+1] - as.matrix(data[index==i,1:p])%*%as.numeric(coef)
    err_sd[i] <- sqrt(mean(resi^2))
    act_num[i] <- sum(abs(coef)>0)
  }
  err_sd_mean <- mean(err_sd)   # only works if error sd is unchanged.
  act_num_mean <- mean(act_num)
  beta <- (act_num_mean+1)*beta # seems to work but there might be better choices

  Fobj <- c(-beta, 0)
  cp_set <- list(NULL,0)
  set <- c(0,1)
  for(t in 2:n)
  {
    m <- length(set)
    cval <- rep(NA, m)
    for(i in 1:m)
    {
      k <- set[i] + 1
      if(t-k>=1) cval[i] <- suppressWarnings(cost(data[k:t,], lambda=err_sd_mean*sqrt(2*log(p)/(t-k+1)))) else cval[i] <- 0 
    }
    obj <- cval + Fobj[set+1] + beta
    min_val <- min(obj)
    ind <- which(obj==min_val)[1]
    cp_set_add <- c(cp_set[[set[ind]+1]], set[ind])
    cp_set <- append(cp_set,list(cp_set_add))
    ind2 <- (cval + Fobj[set+1]) <= min_val
    set <- c(set[ind2], t)
    Fobj <- c(Fobj, min_val)
    if(t%%100==0) print(t)
  }
  cp <- cp_set[[n+1]]
  # nLL <- 0


  cp <- cp[(cp >= trim * n) & (cp <= (1 - trim) * n)]
  cp <- sort(unique(c(0, cp)))

  segment_indices <- which((diff(cp) < trim * n) == TRUE)
  if (length(segment_indices) > 0) {
    cp <- floor(
      (cp[-(segment_indices + 1)] + cp[-segment_indices]) / 2
    )
  }
  cp_loc <- unique(c(0,cp,n))

  # cp_loc <- unique(c(0,cp,n))
  # for(i in 1:(length(cp_loc)-1))
  # {
  #  seg <- (cp_loc[i]+1):cp_loc[i+1]
  #  data_seg <- data[seg,]
  #  out <- glmnet(as.matrix(data_seg[, 1:p]), data_seg[, p+1], lambda=lambda, family=family)
  #  nLL <- deviance(out)/2 + nLL
  # }
  # output <- list(cp, nLL)
  output <- list(cp)
  names(output) <- c("cp")
  return(output)
}

data_gen_lin <- function(n, p, true.coef, true.cp.loc, Sigma, evar) {
  loc <- unique(c(0, true.cp.loc, n))
  if(dim(true.coef)[2] != length(loc)-1) stop("true.coef and true.cp.loc do not match")
  x <- mvtnorm::rmvnorm(n, mean = rep(0, p), sigma = Sigma)
  y <- NULL
  for(i in 1:(length(loc)-1))
  {
    Xb <- x[(loc[i] + 1):loc[i + 1], ,drop=FALSE]%*%true.coef[,i,drop=FALSE]
    add <- Xb + rnorm(length(Xb), sd=sqrt(evar))
    y <- c(y, add)
  }
  data <- cbind(y, x)
  true_cluster <- rep(1:(length(loc)-1), diff(loc))
  result <- list(data, true_cluster)
  return(result)
}

n <- 1500
p <- 50

data_setup <- purrr::cross_df(
  list(
    change_points_count = c(0, 1, 3, 5),
    s = c(3, 6, 10)
  )
)

experiment_setup <- purrr::cross_df(
  list(
    data_setup_index = seq_len(nrow(data_setup)),
    sgd_k = c(1, 2, 3, 5, 7)
  )
)

experiment_num <- 100

rand_gd <- time_gd <- rep(list(rep(NA, experiment_num)), nrow(experiment_setup))
rng <- RNGseq(experiment_num * nrow(data_setup), 4)

cl <- parallel::makeCluster(parallel::detectCores(), outfile = paste0("log/lasso.log"))
doParallel::registerDoParallel(cl)
experiment_result <- foreach::foreach(experiment_setup_index = seq_len(nrow(experiment_setup)), .packages = c("fastglm", "fastcpd", "fossil", "glmnet")) %:%
  foreach::foreach(experiment_index = seq_len(experiment_num), rrng = rng[(experiment_setup$data_setup_index[experiment_setup_index] - 1) * experiment_num + seq_len(experiment_num)], .combine = "rbind") %dopar% {
    rngtools::setRNG(rrng)
    experiment_setup_row <- experiment_setup[experiment_setup_index, ]
    change_points_count <- data_setup[experiment_setup$data_setup_index[experiment_setup_index], ]$change_points_count
    s <- data_setup[experiment_setup$data_setup_index[experiment_setup_index], ]$s
    sgd_k <- experiment_setup_row$sgd_k

    theta_0 <- c(1, 1.2, -1, 0.5, -2)[seq_len(p)]

    true.coef <- matrix(rep(theta_0, change_points_count + 1), nrow = p, ncol = change_points_count + 1)

    theta_norm <- c(0.36, NA, 0.81, NA, 1.96)[p]
    delta <- rnorm(p)
    sigma_ <- 0.9**abs(row(diag(p)) - col(diag(p)))
    delta_coef <- sqrt(theta_norm / t(delta) %*% sigma_ %*% delta)

    seg <- change_points_count + 1
    true.coef <- matrix(rnorm(seg*s), s, seg)
    true.coef <- rbind(true.coef, matrix(0, p-s, seg))
    true.cp.loc <- sort(sample.int(n - 1, change_points_count, replace = FALSE))

    Sigma <- diag(1, p)
    evar <- 0.5
    out <- data_gen_lin(n, p, true.coef, true.cp.loc, Sigma, evar)
    data <- out[[1]]
    g_tr <- out[[2]]
    beta <- (50 + 1) * log(n) / 2

    if (file.exists(paste0("cache/lasso", experiment_setup_index, "_", experiment_index, ".rds"))) {
      rds_file <- readRDS(paste0("cache/lasso", experiment_setup_index, "_", experiment_index, ".rds"))
      cp_set <- rds_file$cp_set
      time_used <- rds_file$time_used
    } else {
      # return(rep(0, 2))
      start <- proc.time()
      if (sgd_k == 7) {
        cp_set <- CP_vanilla_lasso(data[, c(1:p + 1, 1)], beta)$cp
      } else if (sgd_k == 5) {
        lasso_regression_result <- fastcpd(
          data = data,
          beta = beta,
          family = "lasso",
          k = function(x, data_length = n) {
            if (x < data_length / 10 * 1 / 4) 5
            else if (x < data_length / 10 * 2 / 4) 3
            else if (x < data_length / 10 * 3 / 4) 1
            else 0
          },
          epsilon = 1e-5
        )
        cp_set <- lasso_regression_result@cp_set
      } else {
        lasso_regression_result <- fastcpd(
          formula = y ~ . - 1,
          data = data,
          beta = beta,
          family = "lasso",
          k = function(x) sgd_k - 1,
          epsilon = 1e-5
        )
        cp_set <- lasso_regression_result@cp_set
      }
      time_used <- unname((proc.time() - start)[3])
      saveRDS(list(data = data, cp_set = cp_set, time_used = time_used), paste0("cache/lasso", experiment_setup_index, "_", experiment_index, ".rds"))
    }
    cp_gd <- cp_set[!(cp_set==0)]
    K_est <- length(cp_gd) + 1
    cp_un <- unique(c(0, cp_gd, n))
    g_est <- rep(1:K_est, diff(cp_un))
    c(fossil::rand.index(g_tr, g_est), time_used)
  }
parallel::stopCluster(cl)

# n <- 300
# s <- 3
# p <-  5
# evar <- 0.5
# Sigma <- diag(1, p)
# true.cp.loc <- c(100, 225)
# seg <- length(true.cp.loc)+1
# true.coef <- matrix(rnorm(seg*s), s, seg)
# true.coef <- rbind(true.coef, matrix(0, p-s, seg))
# out <- data_gen_lin(n, p, true.coef, true.cp.loc, Sigma, evar)
# data <- out[[1]]
# beta <- log(n)/2

# lasso_result <- fastcpd(
#   data = data,
#   beta = beta,
#   family = "lasso",
#   epsilon = 1e-5
# )

# summary(lasso_result)

experiment_setup_index <- 4
experiment_setup_row <- experiment_setup[experiment_setup_index, ]
change_points_count <- data_setup[experiment_setup$data_setup_index[experiment_setup_index], ]$change_points_count
s <- data_setup[experiment_setup$data_setup_index[experiment_setup_index], ]$s
sgd_k <- experiment_setup_row$sgd_k

theta_0 <- c(1, 1.2, -1, 0.5, -2)[seq_len(p)]

true.coef <- matrix(rep(theta_0, change_points_count + 1), nrow = p, ncol = change_points_count + 1)

theta_norm <- c(0.36, NA, 0.81, NA, 1.96)[p]
delta <- rnorm(p)
sigma_ <- 0.9**abs(row(diag(p)) - col(diag(p)))
delta_coef <- sqrt(theta_norm / t(delta) %*% sigma_ %*% delta)

seg <- change_points_count + 1
true.coef <- matrix(rnorm(seg*s), s, seg)
true.coef <- rbind(true.coef, matrix(0, p-s, seg))
true.cp.loc <- sort(sample.int(n - 1, change_points_count, replace = FALSE))

Sigma <- diag(1, p)
evar <- 0.5
out <- data_gen_lin(n, p, true.coef, true.cp.loc, Sigma, evar)
data <- out[[1]]
g_tr <- out[[2]]
beta <- log(n)/2
lasso_regression_result <- fastcpd(
  data = data,
  beta = beta,
  family = "lasso",
  k = function(x) 0,
  epsilon = 1e-4
)

get_result_lasso <- function(s, change_points_count, sgd_k) {
  data_setup_index <- which(
    data_setup$change_points_count == change_points_count &
    data_setup$s == s
  )
  experiment_setup_index <- which(
    experiment_setup$data_setup_index == data_setup_index &
    experiment_setup$sgd_k == sgd_k
  )
  paste0(format(round(mean(experiment_result[[experiment_setup_index]][, 1]), 3), nsmall = 3), ", ", format(round(mean(experiment_result[[experiment_setup_index]][, 2]), 3), nsmall = 3), "s")
}
@
%

<<lasso regression plot, fig=TRUE, height=5.2, width=7>>=
summary(lasso_regression_result)
plot(lasso_regression_result)
@

\begin{table}[t!]
  \centering
  \begin{tabular}{@{}cccc@{}}
  \toprule
                         & s=3                               & s=6                               & s=10                               \\ \midrule
  \multirow{4}{*}{cpc=0} & \Sexpr{get_result_lasso(3, 0, 1)} & \Sexpr{get_result_lasso(6, 0, 1)} & \Sexpr{get_result_lasso(10, 0, 1)} \\
                         & \Sexpr{get_result_lasso(3, 0, 2)} & \Sexpr{get_result_lasso(6, 0, 2)} & \Sexpr{get_result_lasso(10, 0, 2)} \\
                         & \Sexpr{get_result_lasso(3, 0, 3)} & \Sexpr{get_result_lasso(6, 0, 3)} & \Sexpr{get_result_lasso(10, 0, 3)} \\
                         & \Sexpr{get_result_lasso(3, 0, 5)} & \Sexpr{get_result_lasso(6, 0, 5)} & \Sexpr{get_result_lasso(10, 0, 5)} \\
                         & \Sexpr{get_result_lasso(3, 0, 7)} & \Sexpr{get_result_lasso(6, 0, 7)} & \Sexpr{get_result_lasso(10, 0, 7)} \\ \midrule
  \multirow{4}{*}{cpc=1} & \Sexpr{get_result_lasso(3, 1, 1)} & \Sexpr{get_result_lasso(6, 1, 1)} & \Sexpr{get_result_lasso(10, 1, 1)} \\
                         & \Sexpr{get_result_lasso(3, 1, 2)} & \Sexpr{get_result_lasso(6, 1, 2)} & \Sexpr{get_result_lasso(10, 1, 2)} \\
                         & \Sexpr{get_result_lasso(3, 1, 3)} & \Sexpr{get_result_lasso(6, 1, 3)} & \Sexpr{get_result_lasso(10, 1, 3)} \\
                         & \Sexpr{get_result_lasso(3, 1, 5)} & \Sexpr{get_result_lasso(6, 1, 5)} & \Sexpr{get_result_lasso(10, 1, 5)} \\
                         & \Sexpr{get_result_lasso(3, 1, 7)} & \Sexpr{get_result_lasso(6, 1, 7)} & \Sexpr{get_result_lasso(10, 1, 7)} \\ \midrule
  \multirow{4}{*}{cpc=3} & \Sexpr{get_result_lasso(3, 3, 1)} & \Sexpr{get_result_lasso(6, 3, 1)} & \Sexpr{get_result_lasso(10, 3, 1)} \\
                         & \Sexpr{get_result_lasso(3, 3, 2)} & \Sexpr{get_result_lasso(6, 3, 2)} & \Sexpr{get_result_lasso(10, 3, 2)} \\
                         & \Sexpr{get_result_lasso(3, 3, 3)} & \Sexpr{get_result_lasso(6, 3, 3)} & \Sexpr{get_result_lasso(10, 3, 3)} \\
                         & \Sexpr{get_result_lasso(3, 3, 5)} & \Sexpr{get_result_lasso(6, 3, 5)} & \Sexpr{get_result_lasso(10, 3, 5)} \\
                         & \Sexpr{get_result_lasso(3, 3, 7)} & \Sexpr{get_result_lasso(6, 3, 7)} & \Sexpr{get_result_lasso(10, 3, 7)} \\ \midrule
  \multirow{4}{*}{cpc=5} & \Sexpr{get_result_lasso(3, 5, 1)} & \Sexpr{get_result_lasso(6, 5, 1)} & \Sexpr{get_result_lasso(10, 5, 1)} \\
                         & \Sexpr{get_result_lasso(3, 5, 2)} & \Sexpr{get_result_lasso(6, 5, 2)} & \Sexpr{get_result_lasso(10, 5, 2)} \\
                         & \Sexpr{get_result_lasso(3, 5, 3)} & \Sexpr{get_result_lasso(6, 5, 3)} & \Sexpr{get_result_lasso(10, 5, 3)} \\
                         & \Sexpr{get_result_lasso(3, 5, 5)} & \Sexpr{get_result_lasso(6, 5, 5)} & \Sexpr{get_result_lasso(10, 5, 5)} \\
                         & \Sexpr{get_result_lasso(3, 5, 7)} & \Sexpr{get_result_lasso(6, 5, 7)} & \Sexpr{get_result_lasso(10, 5, 7)} \\ \bottomrule
  \end{tabular}
  \caption{\label{tab:poisson regression comparison} Comparison of the algorithms for the poisson regression model in mean.}
\end{table}

\section{Changes in user specified models with custom cost functions} \label{sec:custom}

\subsection{Reproducing built-in models} \label{sec:reproduce}

<<reproduce built-in logistic models, echo=FALSE>>=
n <- 1500
p <- 5
change_points_count <- 5
sgd_k <- 1

theta_0 <- c(1, 1.2, -1, 0.5, -2)[seq_len(p)]

true.coef <- matrix(rep(theta_0, change_points_count + 1), nrow = p, ncol = change_points_count + 1)

theta_norm <- c(0.36, NA, 0.81, NA, 1.96)[p]
delta <- rnorm(p)
sigma_ <- 0.9**abs(row(diag(p)) - col(diag(p)))
delta_coef <- sqrt(theta_norm / t(delta) %*% sigma_ %*% delta)

true.cp.loc <- n / 6 * seq_len(change_points_count)
true.coef[, 2] <- theta_0 + c(delta_coef) * delta
true.coef[, 4] <- theta_0 - c(delta_coef) * delta
true.coef[, 6] <- theta_0 + c(delta_coef) * delta

Sigma <- diag(1, p)
evar <- 0.5
out <- data_gen_binom(n, p, true.coef, true.cp.loc, Sigma, evar)
data <- out[[1]]
g_tr <- out[[2]]
beta <- log(n)/2
@

<<reproduce built-in logsitic models with custom functions>>=
logistic_regression_result <- fastcpd(
  data = data,
  beta = beta,
  family = "binomial",
  k = function(x) 20,
  epsilon = 1e-5
)

logistic_loss <- function(data, theta) {
  x <- data[, -1]
  y <- data[, 1]
  u <- x %*% theta
  sum(-y * u + log(1 + exp(u)))
}

# logistic_loss2 <- function(data, theta) {
#   x <- data[-1]
#   y <- data[1]
#   u <- x %*% theta
#   -y * u + log(1 + exp(u))
# }

# x <- matrix(rnorm(10000 * 100), ncol = 100)
# theta <- c(0.25, 0, -0.25, rep(0, 97))
# y <- rbinom(10000, 1, 1 / (1 + exp(-x %*% theta)))
# data <- cbind(y, x)

# microbenchmark::microbenchmark(
#   "vectorized" = logistic_loss(data, theta),
#   "consistent" = sum(apply(data, 1, logistic_loss2, theta = theta))
# )

logistic_loss_gradient <- function(data, theta) {
  x <- data[-1]
  y <- data[1]
  c(-(y - 1 / (1 + exp(-x %*% theta)))) * x
}

logistic_loss_hessian <- function(data, theta) {
  x <- data[-1]
  prob <- 1 / (1 + exp(-x %*% theta))
  (x %o% x) * c((1 - prob) * prob)
}
logistic_regression_result_custom <- fastcpd(
  data = data,
  beta = beta,
  k = function(x) 20,
  epsilon = 1e-5,
  cost = logistic_loss,
  cost_gradient = logistic_loss_gradient,
  cost_hessian = logistic_loss_hessian
)
logistic_regression_result@cp_set
logistic_regression_result_custom@cp_set
@

\subsection{Changes in Huber regression models} \label{sec:huber}

<<huber regression>>=
n <- 400 + 300 + 400
p <- 3
x <- mvtnorm::rmvnorm(n, mean = rep(0, p), sigma = diag(p))
theta <- rbind(
  mvtnorm::rmvnorm(1, mean = rep(0, p), sigma = diag(p)),
  mvtnorm::rmvnorm(1, mean = rep(3, p), sigma = diag(p)),
  mvtnorm::rmvnorm(1, mean = rep(5, p), sigma = diag(p))
)
theta <- theta[rep(seq_len(3), c(400, 300, 400)), ]
y_true <- rowSums(x * theta)
factor <- c(
  2 * stats::rbinom(400, size = 1, prob = 0.95) - 1,
  2 * stats::rbinom(300, size = 1, prob = 0.95) - 1,
  2 * stats::rbinom(400, size = 1, prob = 0.95) - 1
)
y <- factor * y_true + stats::rnorm(n)
data <- cbind(y, x)

huber_loss <- function(
  data,
  theta,
  threshold = 1
) {
  residual <- data[, 1] - data[, -1, drop = FALSE] %*% theta
  indicator <- abs(residual) <= threshold
  sum(residual ^ 2 / 2 * indicator + threshold * (abs(residual) - threshold / 2) * (1 - indicator))
}

huber_loss_gradient <- function(data, theta, threshold = 1) {
  residual <- c(data[1] - data[-1] %*% theta)
  if (abs(residual) <= threshold) {
    - residual * data[-1]
  } else {
    - threshold * sign(residual) * data[-1]
  }
}

huber_loss_hessian <- function(
  data,
  theta,
  threshold = 1
) {
  residual <- c(data[1] - data[-1] %*% theta)
  if (abs(residual) <= threshold) {
    outer(data[-1], data[-1])
  } else {
    0.01 * diag(length(theta))
  }
}

huber_regression_result <- fastcpd(
  data = data,
  beta = (p + 1) * log(n),
  cost = huber_loss,
  cost_gradient = huber_loss_gradient,
  cost_hessian = huber_loss_hessian
)

summary(huber_regression_result)
@

\subsection{Changes in quantile regression models} \label{sec:quantile}

%
<<quantile regression>>=
n <- 450
p <- 3
data <- mvtnorm::rmvnorm(n / 5, mean = rep(0, p), sigma = diag(p))[rep(1:(n / 5), each = 5), ]
theta <- matrix(rnorm(p * 2), 2, p)[rep(1:2, c(n * 2 / 3, n / 3)), ]
xb <- rowSums(data * theta)
xb[1:(n / 3 / 5) * 5 + (n / 3) - 4] <- xb[1:(n / 3 / 5) * 5 + (n / 3) - 4] + 50
xb[1:(n / 3 / 5) * 5 + (n / 3) - 3] <- xb[1:(n / 3 / 5) * 5 + (n / 3) - 3] + 40
xb[1:(n / 3 / 5) * 5 + (n / 3) - 1] <- xb[1:(n / 3 / 5) * 5 + (n / 3) - 1] - 5
xb[1:(n / 3 / 5) * 5 + (n / 3)] <- xb[1:(n / 3 / 5) * 5 + (n / 3)] - 10
data <- cbind(xb, data)
@
%
Verify that the data contains three parts with two segments. The first segment
is from 1 to 300 and the second segment is from 301 to 450. By doing piecewise
quantile regression and linear regression, we can verify that coefficients of
quantile regression in the first 150 observations are the same as those in the
second 150 observations. The coefficients of linear regression in the first 150
observations are different from those in the second 150 observations.

\begin{table}[t!]
\centering
\begin{tabular}{llp{10cm}}
\hline
Algorithm           & Data    & Coefficients \\ \hline
Quantile Regression & 1st 150 & \Sexpr{unname(quantreg::rq(data[1:(n / 3), 1] ~ data[1:(n / 3), -1] - 1, 0.5)$coefficients)} \\
Quantile Regression & 2nd 150 & \Sexpr{unname(quantreg::rq(data[101:(n * 2 / 3), 1] ~ data[101:(n * 2 / 3), -1] - 1, 0.5)$coefficients)} \\
Quantile Regression & 3rd 150 & \Sexpr{unname(quantreg::rq(data[(n * 2 / 3 + 1):n, 1] ~ data[(n * 2 / 3 + 1):n, -1] - 1, 0.5)$coefficients)} \\
Linear Regression   & 1st 150 & \Sexpr{unname(lm(data[1:(n / 3), 1] ~ data[1:(n / 3), -1] - 1)$coefficients)} \\ \hline
Linear Regression   & 2nd 150 & \Sexpr{unname(lm(data[101:(n * 2 / 3), 1] ~ data[101:(n * 2 / 3), -1] - 1)$coefficients)} \\ \hline
Linear Regression   & 3rd 150 & \Sexpr{unname(lm(data[(n * 2 / 3 + 1):n, 1] ~ data[(n * 2 / 3 + 1):n, -1] - 1)$coefficients)} \\ \hline
\end{tabular}
\caption{\label{tab:logistic regression comparison} Comparison of the
algorithms for the logistic regression model.}
\end{table}

Let see what is the output if we misspecify the model.
%
<<quantile regression misspecification>>=
# linear_regression_result <- fastcpd(
#   data = data,
#   beta = log(n) / 2,
#   segment_count = 10,
#   trim = 0.025,
#   k = function(x) 0,
#   family = "gaussian",
#   epsilon = 1e-5
# )

# summary(linear_regression_result)
@
%
The output is not correct. Now let see what is the output if we specify the
model to be a quantile regression model using the custom cost function.
%
<<quantile regression correct model>>=
quantile_loss <- function(
  data,
  theta,
  quant = 0.5,
  smoothing = 0.25
) {
  residual <- data[, 1] - data[, -1, drop = FALSE] %*% theta
  mean(residual * (quant - (residual < 0)))
}

quantile_loss_gradient <- function(
  data, theta, quant = 0.5, smoothing = 0.25
) {
  c(quant - 1 / (1 + exp(c(data[1] - data[-1] %*% theta) / smoothing))) * data[-1]
}

quantile_loss_hessian <- function(
  data,
  theta,
  quant = 0.5,
  smoothing = 0.25
) {
  # - exp(c(data[1] - data[-1] %*% theta) / smoothing) / (smoothing * (1 + exp(c(data[1] - data[-1] %*% theta) / smoothing))^2) * data[-1] %o% data[-1]
  0.01 * diag(length(theta))
}
@
%

\begin{figure}[t!]
\centering
% <<quantile regression visualization, echo=FALSE, fig=TRUE, height=5.2, width=7>>=
% ggplot2::autoplot(benchmarked)
% @
\caption{\label{fig:quantile regression bench mark} Benchmarking results for
the quantile regression model.}
\end{figure}

\subsection{Changes in mean shift models} \label{sec:mean shift model}

Now let's consider the mean shift model using custom cost function. Since a
mean shift model is a special case of a linear regression model, by specifying a
response variable we can use the linear regression model to detect the change
points. Now let's see what would be the output if we use the custom cost function.
%
<<mean shift model with gaussian family>>=
p <- 1
data <- rbind(
  mvtnorm::rmvnorm(300, mean = rep(0, p), sigma = diag(1, p)),
  mvtnorm::rmvnorm(400, mean = rep(5, p), sigma = diag(1, p)),
  mvtnorm::rmvnorm(300, mean = rep(2, p), sigma = diag(1, p))
)

mean_loss <- function(data) {
  # norm(sweep(data, 2, theta), type = "F") ^ 2 / 2
  (norm(data, type = "F") ^ 2 - colSums(data) ^ 2 / nrow(data)) / 2 / cov(data) + nrow(data) / 2 * (log(cov(data)) + log(2 * pi))
}

# mean_loss_gradient <- function(data, theta) {
#   (theta - data[nrow(data), ]) / c(cov(data))
# }

# mean_loss_hessian <- function(data, theta) {
#   diag(1 / c(cov(data)), p)
# }

mean_loss_result <- fastcpd(
  data = data,
  beta = (p + 1) * log(nrow(data)) / 2,
  p = p,
  cost = mean_loss
)

summary(mean_loss_result)
changepoint::cpt.mean(c(data), method = "PELT")

data <- cbind(
  c(
    data[1:300, , drop = FALSE] %*% colMeans(data[1:300, , drop = FALSE]),
    data[301:700, , drop = FALSE] %*% colMeans(data[301:700, , drop = FALSE]),
    data[701:1000, , drop = FALSE] %*% colMeans(data[701:1000, , drop = FALSE])
  ),
  data
)

mean_shift_linear_result <- fastcpd(
  data = data,
  beta = log(1000) / 2,
  segment_count = 5,
  trim = 0.025,
  k = function(x) 0,
  family = "gaussian",
  epsilon = 1e-5
)
summary(mean_shift_linear_result)
@

<<variance change model with gaussian family>>=
p <- 1
data <- rbind(
  mvtnorm::rmvnorm(300, mean = rep(0, p), sigma = diag(1, p)),
  mvtnorm::rmvnorm(400, mean = rep(0, p), sigma = diag(50, p)),
  mvtnorm::rmvnorm(300, mean = rep(0, p), sigma = diag(2, p))
)

data_all_mu <- colMeans(data)

var_loss <- function(data) {
  demeaned_data <- sweep(data, 2, data_all_mu)
  # norm(demeaned_data, type = "F") ^ 2 / 2 / theta ^ 2 + nrow(data) * log(theta ^ 2) / 2
  nrow(data) * (1 + log(2 * pi) + log(norm(demeaned_data, type = "F") ^ 2 / nrow(data))) / 2
}

# var_loss_gradient <- function(data, theta) {
#   # -data ^ 2 / theta^3 + 1 / theta
#   - (data[nrow(data), ] - data_all_mu) ^ 2 / theta ^ 2 + 1 / 2 / theta
# }

# var_loss_hessian <- function(data, theta) {
#   # 3 * data ^ 2 / theta^4 - 1 / theta ^ 2
#   (data[nrow(data), ] - data_all_mu) ^ 2 / theta ^ 3 - 1 / 2 / theta ^ 2
# }

var_loss_result <- fastcpd(
  data = data,
  beta = (p + 1) * log(nrow(data)) / 2,
  p = p,
  cost = var_loss
)

summary(var_loss_result)
changepoint::cpt.var(c(data), method = "PELT")
@

<<mean and variance change model with gaussian family>>=
p <- 1
data <- rbind(
  mvtnorm::rmvnorm(300, mean = rep(0, p), sigma = diag(1, p)),
  mvtnorm::rmvnorm(400, mean = rep(10, p), sigma = diag(1, p)),
  mvtnorm::rmvnorm(300, mean = rep(0, p), sigma = diag(50, p)),
  mvtnorm::rmvnorm(300, mean = rep(0, p), sigma = diag(1, p)),
  mvtnorm::rmvnorm(400, mean = rep(10, p), sigma = diag(1, p)),
  mvtnorm::rmvnorm(300, mean = rep(10, p), sigma = diag(50, p))
)

meanvar_loss <- function(data) {
  # mu <- theta[seq_len(p)]
  # sigma_2 <- theta[-seq_len(p)]
  # norm(sweep(data, 2, mu), type = "F") ^ 2 / 2 / sigma_2 ^ 2 + nrow(data) * log(sigma_2 ^ 2) / 2
  nrow(data) * (1 + log(2 * pi) + log((colSums(data ^ 2) - colSums(data) ^ 2 / nrow(data)) / nrow(data))) / 2
}

# meanvar_loss_gradient <- function(data, theta) {
#   mu <- theta[seq_len(p)]
#   sigma_2 <- theta[-seq_len(p)]
#   # c((mu - data) / sigma_2 ^ 2, -(data - mu) ^ 2 / sigma_2^3 + 1 / sigma_2)
#   c((mu - data[nrow(data), ]) / sigma_2, -(data[nrow(data), ] - mu) ^ 2 / 2 / sigma_2 ^ 2 + 1 / 2 / sigma_2)
# }

# meanvar_loss_hessian <- function(data, theta) {
#   mu <- theta[seq_len(p)]
#   sigma_2 <- theta[-seq_len(p)]
#   # matrix(c(1 / sigma_2 ^ 2, -2 * (mu - data) / sigma_2 ^ 3, -2 * (mu - data) / sigma_2 ^ 3, 3 * (data - mu) ^ 2 / sigma_2^4 - 1 / sigma_2 ^ 2), nrow = 2, ncol = 2)
#   matrix(c(
#     1 / sigma_2,
#     (data[nrow(data), ] - mu) / sigma_2 ^ 2,
#     (data[nrow(data), ] - mu) / sigma_2 ^ 2,
#     (data[nrow(data), ] - mu) ^ 2 / sigma_2 ^ 3 - 1 / 2 / sigma_2 ^ 2
#   ), nrow = 2, ncol = 2)
# }

meanvar_loss_result <- fastcpd(
  data = data,
  beta = (2 * p + 1) * log(nrow(data)) / 2,
  p = 2 * p,
  cost = meanvar_loss
)

summary(meanvar_loss_result)
changepoint::cpt.meanvar(c(data), method = "PELT")
@

\section{Adaptive number of epochs} \label{sec:adaptive number of epochs}

In this section, we will discuss how to use the adaptive number of epochs
feature in \pkg{fastcpd}. The adaptive number of epochs feature is designed to
automatically determine the number of epochs to run the algorithm. The criteria
for determining the number of epochs is based on the following function:
%
\begin{equation} \label{eq:adaptive number of epochs}
  K = \min(\max(\boldsymbol{k}, \lceil \frac{1000}{\text{segment length}} \rceil), 10)
\end{equation}
%
where $K$ is the number of epochs to run the algorithm, $\boldsymbol{k}$ is the
number of epochs specified by the user parameter \code{sgd_k}, and \code{segment length} is the
length of the segment. The goal is to upper limit the number of epochs to 10
when the segment length is small and to lower limit the number of epochs to
$\boldsymbol{k}$. The transition between the upper limit and lower limit is
calculated by $\lceil 1000 / \text{segment length} \rceil$.

<<adaptive number of epochs>>=
kfunc <- function(x, data_length = n) {
  if (x < data_length / 10 * 1 / 4) 5
  else if (x < data_length / 10 * 2 / 4) 3
  else if (x < data_length / 10 * 3 / 4) 1
  else 0
}
@

%% -- Summary/conclusions/discussion -------------------------------------------

\section{Summary and discussion} \label{sec:summary}

Our package \pkg{fastcpd} provides a fast and flexible implementation of
change point detection algorithms. The package is designed to be easy to use
and to provide a wide range of options for the user. The package is
implemented in \proglang{R} and is available on GitHub.


%% -- Optional special unnumbered sections -------------------------------------

\section*{Computational details}

\begin{leftbar}
If necessary or useful, information about certain computational details
such as version numbers, operating systems, or compilers could be included
in an unnumbered section. Also, auxiliary packages (say, for visualizations,
maps, tables, \dots) that are not cited in the main text can be credited here.
\end{leftbar}

The results in this paper were obtained using
\proglang{R}~\Sexpr{paste(R.Version()[6:7], collapse = ".")} with the
\pkg{MASS}~\Sexpr{packageVersion("MASS")} package. \proglang{R} itself
and all packages used are available from the Comprehensive
\proglang{R} Archive Network (CRAN) at
\url{https://CRAN.R-project.org/}.


\section*{Acknowledgments}

\begin{leftbar}
All acknowledgments (note the AE spelling) should be collected in this
unnumbered section before the references. It may contain the usual information
about funding and feedback from colleagues/reviewers/etc. Furthermore,
information such as relative contributions of the authors may be added here
(if any).
\end{leftbar}


%% -- Bibliography -------------------------------------------------------------
%% - References need to be provided in a .bib BibTeX database.
%% - All references should be made with \cite, \citet, \citep, \citealp etc.
%%   (and never hard-coded). See the FAQ for details.
%% - JSS-specific markup (\proglang, \pkg, \code) should be used in the .bib.
%% - Titles in the .bib should be in title case.
%% - DOIs should be included where available.

\bibliography{refs}


%% -- Appendix (if any) --------------------------------------------------------
%% - After the bibliography with page break.
%% - With proper section titles and _not_ just "Appendix".

\newpage

\begin{appendix}

\section{More technical details} \label{app:technical}

\begin{leftbar}
Appendices can be included after the bibliography (with a page break). Each
section within the appendix should have a proper section title (rather than
just \emph{Appendix}).

For more technical style details, please check out JSS's style FAQ at
\url{https://www.jstatsoft.org/pages/view/style#frequently-asked-questions}
which includes the following topics:
\begin{itemize}
  \item Title vs.\ sentence case.
  \item Graphics formatting.
  \item Naming conventions.
  \item Turning JSS manuscripts into \proglang{R} package vignettes.
  \item Trouble shooting.
  \item Many other potentially helpful details\dots
\end{itemize}
\end{leftbar}


\section[Using BibTeX]{Using \textsc{Bib}{\TeX}} \label{app:bibtex}

\begin{leftbar}
References need to be provided in a \textsc{Bib}{\TeX} file (\code{.bib}). All
references should be made with \verb|\cite|, \verb|\citet|, \verb|\citep|,
\verb|\citealp| etc.\ (and never hard-coded). This commands yield different
formats of author-year citations and allow to include additional details (e.g.,
pages, chapters, \dots) in brackets. In case you are not familiar with these
commands see the JSS style FAQ for details.

Cleaning up \textsc{Bib}{\TeX} files is a somewhat tedious task -- especially
when acquiring the entries automatically from mixed online sources. However,
it is important that informations are complete and presented in a consistent
style to avoid confusions. JSS requires the following format.
\begin{itemize}
  \item JSS-specific markup (\verb|\proglang|, \verb|\pkg|, \verb|\code|) should
    be used in the references.
  \item Titles should be in title case.
  \item Journal titles should not be abbreviated and in title case.
  \item DOIs should be included where available.
  \item Software should be properly cited as well. For \proglang{R} packages
    \code{citation("pkgname")} typically provides a good starting point.
\end{itemize}
\end{leftbar}

\end{appendix}

%% -----------------------------------------------------------------------------


\end{document}
