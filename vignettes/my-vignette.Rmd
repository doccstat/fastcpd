---
title: "my-vignette"
output: rmarkdown::pdf_document
vignette: >
  %\VignetteIndexEntry{my-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(cpd)
```

```{r}
set.seed(100)
n <- 300
p <- 8
tau <- c(0.45, 1)
mu <- matrix(c(-1, rnorm(p - 1, 0.5, 0.1)), p, n)
K <- length(tau)
for (i in 1:(K - 1))
{
  st <- floor(n * tau[i] + 1)
  en <- floor(n * tau[i + 1])
  mu[, st:en] <- c((-1)^(i + 1), rnorm(p - 1, 0.5, 0.1))
}
g_tr <- rep(1:K, diff(c(0, tau * n)))
beta <- (p + 1) * log(n) / 2

X <- matrix(rnorm(n * (p - 1), 0), n, p - 1)
X <- cbind(1, X)
eta <- apply(t(mu) * X, 1, sum)
prob <- 1 / (1 + exp(-eta))
Y <- rbinom(n, size = 1, prob = prob)
data <- cbind(Y, X)
```

```{r}
CP(data, beta, sgd_k = 1, family = "binomial")$cp
```

```{r}
CP(data, beta, sgd_k = 3, family = "binomial")$cp
```

```{r}
CP_vanilla(data, beta, family = "binomial")$cp
```

Now see the original code:
```{r}
# Logistic regression

cost_glm <- function(data, family="binomial")
  {
  data <- as.matrix(data)
  p <- dim(data)[2] - 1
  out <- fastglm::fastglm(as.matrix(data[,1:p]), data[,p+1], family=family)
  return(out$deviance/2)
  }

# Dynamic Programming with Pruning

CP_vanilla <- function(data, beta, cost=cost_glm)
{
n <- dim(data)[1]
p <- dim(data)[2] - 1
Fobj <- c(-beta, 0)
cp_set <- list(NULL,0)
set <- c(0,1)
 for(t in 2:n)
 {
 m <- length(set)
 cval <- rep(NA, m)
  for(i in 1:m)
  {
  k <- set[i] + 1
  if(t-k>=p-1) cval[i] <- suppressWarnings(cost(data[k:t,])) else cval[i] <- 0
  }
 obj <- cval + Fobj[set+1] + beta
 min_val <- min(obj)
 ind <- which(obj==min_val)[1]
 cp_set_add <- c(cp_set[[set[ind]+1]], set[ind])
 cp_set <- append(cp_set,list(cp_set_add))
 ind2 <- (cval + Fobj[set+1]) <= min_val
 set <- c(set[ind2], t)
 Fobj <- c(Fobj, min_val)
 if(t%%100==0) print(t)
 }
cp <- cp_set[[n+1]]
nLL <- 0
cp_loc <- unique(c(0,cp,n))
for(i in 1:(length(cp_loc)-1))
 {
 seg <- (cp_loc[i]+1):cp_loc[i+1]
 data_seg <- data[seg,]
 out <- fastglm::fastglm(as.matrix(data_seg[, 1:p]), data_seg[, p+1], family="binomial")
 nLL <- out$deviance/2 + nLL
 }

output <- list(cp, nLL)
names(output) <- c("cp", "nLL")
return(output)
}

##################################################
# Solve logistic regression using Gradient Descent
# Extension to the multivariate case
##################################################

cost_logistic_update <- function(data_new, coef, cum_coef, cmatrix, epsilon=1e-10)
  {
  p <- length(data_new) - 1
  X_new <- data_new[1:p]
  Y_new <- data_new[p+1]
  eta <- X_new%*%coef
  mu <- 1/(1+exp(-eta))
  cmatrix <- cmatrix + (X_new%o%X_new)*as.numeric((1-mu)*mu)
  lik_dev <- as.numeric(-(Y_new - mu))*X_new
  coef <-  coef - solve(cmatrix+epsilon*diag(1,p), lik_dev)
  cum_coef <- cum_coef + coef
  return(list(coef, cum_coef, cmatrix))
  }

neg_log_lik <- function(data, b)
  {
  p <- dim(data)[2] - 1
  X <- data[, 1:p, drop=FALSE]
  Y <- data[, p+1, drop=FALSE]
  u <- as.numeric(X%*%b)
  L <- - Y*u + log(1+exp(u))
  return(sum(L))
  }

# Dynamic Programming with Pruning and Gradient Descent

CP <- function(data, beta, B=10, trim=0.025)
{
  n <- dim(data)[1]
  p <- dim(data)[2] - 1
  Fobj <- c(-beta, 0)
  cp_set <- list(NULL,0)
  set <- c(0,1)

  # choose the initial values based on pre-segmentation

  index <- rep(1:B, rep(n/B,B))
  coef.int <- matrix(NA, B, p)
  for(i in 1:B)
  {
  out <- fastglm::fastglm(as.matrix(data[index==i,1:p]), data[index==i,p+1], family="binomial")
  coef.int[i,] <- stats::coef(out)
  }
  X1 <- data[1,1:p]
  cum_coef <- coef <- matrix(coef.int[1,], p, 1)
  e_eta <- exp(coef%*%X1)
  const <- e_eta/(1+e_eta)^2
  cmatrix <- array((X1%o%X1)*as.numeric(const),c(p,p,1))

  for(t in 2:n)
   {
   m <- length(set)
   cval <- rep(NA, m)

   for(i in 1:(m-1))
    {
    coef_c <- coef[,i]
    cum_coef_c <- cum_coef[,i]
    cmatrix_c <- cmatrix[,,i]
    out <- cost_logistic_update(data[t,], coef_c, cum_coef_c, cmatrix_c)
    coef[,i] <- out[[1]]
    cum_coef[,i] <- out[[2]]
    cmatrix[,,i] <- out[[3]]
    k <- set[i] + 1
    if(t-k>=p-1) cval[i] <- neg_log_lik(data[k:t,], cum_coef[,i]/(t-k+1)) else cval[i] <- 0
   }

  # the choice of initial values requires further investigation

  cval[m] <- 0
  Xt <- data[t,1:p]
  cum_coef_add <- coef_add <- coef.int[index[t],]
  e_eta_t <- exp(coef_add%*%Xt)
  const <- e_eta_t/(1+e_eta_t)^2
  cmatrix_add <- (Xt%o%Xt)*as.numeric(const)

  coef <- cbind(coef,coef_add)
  cum_coef <- cbind(cum_coef,cum_coef_add)
  cmatrix <- abind::abind(cmatrix, cmatrix_add, along=3)

  # Adding a momentum term (TBD)

  obj <- cval + Fobj[set+1] + beta
  min_val <- min(obj)
  ind <- which(obj==min_val)[1]
  cp_set_add <- c(cp_set[[set[ind]+1]], set[ind])
  cp_set <- append(cp_set,list(cp_set_add))
  ind2 <- (cval + Fobj[set+1]) <= min_val
  set <- c(set[ind2], t)
  coef <- coef[,ind2,drop=FALSE]
  cum_coef <- cum_coef[,ind2,drop=FALSE]
  cmatrix <- cmatrix[,,ind2,drop=FALSE]
  Fobj <- c(Fobj, min_val)
  }

  # Remove change-points close to the boundaries

  cp <- cp_set[[n+1]]
  if(length(cp)>0)
  {
   ind3 <- (1:length(cp))[(cp<trim*n)|(cp>(1-trim)*n)]
   cp <- cp[-ind3]
  }

  nLL <- 0
  cp_loc <- unique(c(0,cp,n))
  for(i in 1:(length(cp_loc)-1))
  {
    seg <- (cp_loc[i]+1):cp_loc[i+1]
    data_seg <- data[seg,]
    out <- fastglm::fastglm(as.matrix(data_seg[, 1:p]), data_seg[, p+1], family="binomial")
    nLL <- out$deviance/2 + nLL
  }

  output <- list(cp, nLL)
  names(output) <- c("cp", "nLL")
return(output)
}
```

```{r}
CP(cbind(X, Y), beta)$cp
```
