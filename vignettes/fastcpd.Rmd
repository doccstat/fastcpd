---
title: "fastcpd"
output: rmarkdown::pdf_document
vignette: >
  %\VignetteIndexEntry{fastcpd}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(fastcpd)
```

```{r}
set.seed(100)
n <- 500
p <- 8
tau <- c(0.45, 1)
theta <- matrix(c(-1, rnorm(p - 1, 0.5, 0.1)), p, n)
for (i in 1:(length(tau) - 1)) {
  segment_start <- floor(n * tau[i] + 1)
  segment_end <- floor(n * tau[i + 1])
  theta[, segment_start:segment_end] <- c((-1)^(i + 1), rnorm(p - 1, 0.5, 0.1))
}
beta <- (p + 1) * log(n) / 2

x <- cbind(1, mvtnorm::rmvnorm(n, rep(0, p - 1), diag(p - 1)))
xb <- rowSums(t(theta) * x)
y <- rbinom(n, size = 1, prob = 1 / (1 + exp(-xb)))
data <- cbind(y, x)
```

```{r}
fastcpd_result_1 <- fastcpd(data, beta, sgd_k = 1, family = "binomial")$cp_set
fastcpd_result_5 <- fastcpd(data, beta, sgd_k = 5, family = "binomial")$cp_set
cp_vanilla_result <- CP_vanilla(data, beta, family = "binomial")$cp_set
cat("fastcpd with sgd_k = 1: ", fastcpd_result_1, "\nfastcpd with sgd_k = 5: ", fastcpd_result_5, "\nvanilla: ", cp_vanilla_result)
```

```{r}
microbenchmark::microbenchmark(
  fastcpd(data, beta, sgd_k = 5, family = "binomial"),
  CP_vanilla(data, beta, family = "binomial"),
  times = 1
)
```

```{r}
y <- rpois(n, lambda = exp(xb))
data <- cbind(y, x)
```

```{r}
fastcpd_result_1 <- fastcpd(
  data = data,
  beta = beta,
  segment_count = 10,
  trim = 0.03,
  sgd_k = 1,
  family = "poisson",
  epsilon = 0.001,
  min_prob = 10^10,
  winsorise_minval = -20,
  winsorise_maxval = 20
)$cp_set
fastcpd_result_5 <- fastcpd(data, beta, sgd_k = 5, family = "poisson")$cp_set
cp_vanilla_result <- CP_vanilla(data, beta, family = "poisson")$cp_set
cat("fastcpd with sgd_k = 1: ", fastcpd_result_1, "\nfastcpd with sgd_k = 5: ", fastcpd_result_5, "\nvanilla: ", cp_vanilla_result)
```


```{r}
data_gen_lin <- function(n, p, true.coef, true.cp.loc, Sigma, evar) {
  loc <- unique(c(0, true.cp.loc, n))
  if(dim(true.coef)[2] != length(loc)-1) stop("true.coef and true.cp.loc do not match")
  x <- mvtnorm::rmvnorm(n, mean = rep(0, p), sigma = Sigma)
  y <- NULL
  for(i in 1:(length(loc)-1))
  {
    Xb <- x[(loc[i] + 1):loc[i + 1], ,drop=FALSE]%*%true.coef[,i,drop=FALSE]
    add <- Xb + rnorm(length(Xb), sd=sqrt(evar))
    y <- c(y, add)
  }
  data <- cbind(y, x)
  true_cluster <- rep(1:(length(loc)-1), diff(loc))
  result <- list(data, true_cluster)
  return(result)
}

n <- 300
s <- 3
p <-  5
evar <- 0.5
Sigma <- diag(1, p)
true.cp.loc <- c(100, 225)
seg <- length(true.cp.loc)+1
true.coef <- matrix(rnorm(seg*s), s, seg)
true.coef <- rbind(true.coef, matrix(0, p-s, seg))
out <- data_gen_lin(n, p, true.coef, true.cp.loc, Sigma, evar)
data <- out[[1]]
beta <- log(n)/2   # beta here has different meaning


fastcpd(
  data = data,
  beta = beta,
  segment_count = 10,
  trim = 0.025,
  sgd_k = 1,
  family = "lasso",
  epsilon = 1e-5
)$cp_set

fastcpd(
  data = data,
  beta = beta,
  segment_count = 10,
  trim = 0.025,
  sgd_k = 1,
  family = "gaussian",
  epsilon = 1e-5
)$cp_set

n <- 450
p <- 3
data <- mvtnorm::rmvnorm(n / 5, mean = rep(0, p), sigma = diag(p))[rep(1:(n / 5), each = 5), ]
theta <- matrix(rnorm(p * 2), 2, p)[rep(1:2, c(n * 2 / 3, n / 3)), ]
xb <- rowSums(data * theta)
xb[1:(n / 3 / 5) * 5 + (n / 3) - 4] <- xb[1:(n / 3 / 5) * 5 + (n / 3) - 4] + 50
xb[1:(n / 3 / 5) * 5 + (n / 3) - 3] <- xb[1:(n / 3 / 5) * 5 + (n / 3) - 3] + 40
xb[1:(n / 3 / 5) * 5 + (n / 3) - 1] <- xb[1:(n / 3 / 5) * 5 + (n / 3) - 1] - 5
xb[1:(n / 3 / 5) * 5 + (n / 3)] <- xb[1:(n / 3 / 5) * 5 + (n / 3)] - 10
data <- cbind(xb, data)

quantreg::rq(data[1:(n / 3), 1] ~ data[1:(n / 3), -1] - 1, 0.5)$coefficients
quantreg::rq(data[101:(n * 2 / 3), 1] ~ data[101:(n * 2 / 3), -1] - 1, 0.5)$coefficients
quantreg::rq(data[(n * 2 / 3 + 1):n, 1] ~ data[(n * 2 / 3 + 1):n, -1] - 1, 0.5)$coefficients
lm(data[1:(n / 3), 1] ~ data[1:(n / 3), -1] - 1)$coefficients
lm(data[101:(n * 2 / 3), 1] ~ data[101:(n * 2 / 3), -1] - 1)$coefficients
lm(data[(n * 2 / 3 + 1):n, 1] ~ data[(n * 2 / 3 + 1):n, -1] - 1)$coefficients

fastcpd(
  data = data,
  beta = log(n) / 2,
  segment_count = 10,
  trim = 0.025,
  sgd_k = 1,
  family = "gaussian",
  epsilon = 1e-5
)$cp_set

quantile_loss <- function(
  data,
  theta,
  family = "custom",
  lambda = NULL,
  cv = NULL,
  quant = 0.5,
  smoothing = 0.25
) {
  data <- as.matrix(data)

  if (is.null(theta)) {

    rq_result <- quantreg::rq(data[, 1] ~ data[, -1, drop = FALSE] - 1, quant)
    residual <- data[, 1] - rq_result$fitted.values
    list(theta = rq_result$coefficients, val = mean(residual * (quant - (residual < 0))))

  } else {

    residual <- data[, 1] - data[, -1, drop = FALSE] %*% theta
    mean(residual * (quant - (residual < 0)))

  }
}

quantile_loss_gradient <- function(
  data, theta, family = "custom", quant = 0.5, smoothing = 0.25
) {
  c(quant - 1 / (1 + exp(c(data[1] - data[-1] %*% theta) / smoothing))) * data[-1]
}

quantile_loss_hessian <- function(
  data,
  theta,
  hessian,
  family = "custom",
  min_prob = NULL,
  quant = 0.5,
  smoothing = 0.25
) {
  # hessian - exp(c(data[1] - data[-1] %*% theta) / smoothing) / (smoothing * (1 + exp(c(data[1] - data[-1] %*% theta) / smoothing))^2) * data[-1] %o% data[-1]
  hessian + 0.01 * diag(length(theta))
}

fastcpd(
  data = data,
  beta = log(n) / 2,
  segment_count = 5,
  trim = 0.025,
  sgd_k = 20,
  cost = quantile_loss,
  cost_gradient = quantile_loss_gradient,
  cost_hessian = quantile_loss_hessian
)$cp_set
```

```{r}
p <- 1
data <- rbind(
  mvtnorm::rmvnorm(100, mean = rep(0, p), sigma = diag(1, p)),
  mvtnorm::rmvnorm(100, mean = rep(5, p), sigma = diag(1, p))
)
data <- cbind(c(data[1:100, , drop = FALSE] %*% colMeans(data[1:100, , drop = FALSE]), data[101:200, , drop = FALSE] %*% colMeans(data[101:200, , drop = FALSE])), data)

fastcpd(
  data = data,
  beta = log(200) / 2,
  segment_count = 3,
  trim = 0.025,
  sgd_k = 1,
  family = "gaussian",
  epsilon = 1e-5
)$cp_set

data <- data[, -1, drop = FALSE]

mean_loss <- function(data, theta, ...) {
  data <- as.matrix(data)

  if (is.null(theta)) {

    theta <- colMeans(data)
    list(theta = theta, val = norm(sweep(data, 2, theta), type = "F") ^ 2 / 2)

  } else {

    norm(sweep(data, 2, theta), type = "F") ^ 2 / 2

  }
}

mean_loss_gradient <- function(data, theta, ...) {
  theta - data
}

mean_loss_hessian <- function(data, theta, hessian, ...) {
  hessian + diag(p)
}

fastcpd(
  data = data,
  beta = 10,
  segment_count = 4,
  trim = 0.025,
  sgd_k = 1,
  p = p,
  cost = mean_loss,
  cost_gradient = mean_loss_gradient,
  cost_hessian = mean_loss_hessian
)$cp_set
```
